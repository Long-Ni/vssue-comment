<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 多线程基础 | Ni&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="$page.excerpt">
    
    <link rel="preload" href="/vssue-comment/assets/css/0.styles.02c2761a.css" as="style"><link rel="preload" href="/vssue-comment/assets/js/app.9fa4f4bb.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/13.044f1fde.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/3.f0de84e7.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/18.02aac107.js" as="script"><link rel="prefetch" href="/vssue-comment/assets/js/10.23cc3d6b.js"><link rel="prefetch" href="/vssue-comment/assets/js/11.c63e2dcc.js"><link rel="prefetch" href="/vssue-comment/assets/js/12.d7671ee7.js"><link rel="prefetch" href="/vssue-comment/assets/js/14.399fc32e.js"><link rel="prefetch" href="/vssue-comment/assets/js/15.37bef016.js"><link rel="prefetch" href="/vssue-comment/assets/js/16.2ae3cc61.js"><link rel="prefetch" href="/vssue-comment/assets/js/17.10c0352f.js"><link rel="prefetch" href="/vssue-comment/assets/js/19.ac0b8b1d.js"><link rel="prefetch" href="/vssue-comment/assets/js/20.656ccc17.js"><link rel="prefetch" href="/vssue-comment/assets/js/21.d1f01d1a.js"><link rel="prefetch" href="/vssue-comment/assets/js/22.6e251d71.js"><link rel="prefetch" href="/vssue-comment/assets/js/23.caaa7b12.js"><link rel="prefetch" href="/vssue-comment/assets/js/24.33d428f1.js"><link rel="prefetch" href="/vssue-comment/assets/js/25.207f6b5f.js"><link rel="prefetch" href="/vssue-comment/assets/js/26.398d8fee.js"><link rel="prefetch" href="/vssue-comment/assets/js/27.d4ae83e5.js"><link rel="prefetch" href="/vssue-comment/assets/js/28.66c58624.js"><link rel="prefetch" href="/vssue-comment/assets/js/29.a6686645.js"><link rel="prefetch" href="/vssue-comment/assets/js/30.242e18b7.js"><link rel="prefetch" href="/vssue-comment/assets/js/31.7da4eecc.js"><link rel="prefetch" href="/vssue-comment/assets/js/32.9b8f3ea0.js"><link rel="prefetch" href="/vssue-comment/assets/js/33.075dbe36.js"><link rel="prefetch" href="/vssue-comment/assets/js/34.838ce186.js"><link rel="prefetch" href="/vssue-comment/assets/js/35.3bbd155f.js"><link rel="prefetch" href="/vssue-comment/assets/js/36.a07ab564.js"><link rel="prefetch" href="/vssue-comment/assets/js/37.50ef72a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/38.75b498ed.js"><link rel="prefetch" href="/vssue-comment/assets/js/39.3b1e3afb.js"><link rel="prefetch" href="/vssue-comment/assets/js/4.79c2a3ee.js"><link rel="prefetch" href="/vssue-comment/assets/js/40.0a6fdf1b.js"><link rel="prefetch" href="/vssue-comment/assets/js/41.9be8ec60.js"><link rel="prefetch" href="/vssue-comment/assets/js/42.9ce4d2b3.js"><link rel="prefetch" href="/vssue-comment/assets/js/43.c76f9c55.js"><link rel="prefetch" href="/vssue-comment/assets/js/44.4749cc3b.js"><link rel="prefetch" href="/vssue-comment/assets/js/45.605778e4.js"><link rel="prefetch" href="/vssue-comment/assets/js/46.fd2913a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/47.5b787534.js"><link rel="prefetch" href="/vssue-comment/assets/js/48.7cf6064e.js"><link rel="prefetch" href="/vssue-comment/assets/js/49.ffa11e3d.js"><link rel="prefetch" href="/vssue-comment/assets/js/5.6a98c4eb.js"><link rel="prefetch" href="/vssue-comment/assets/js/50.69284de8.js"><link rel="prefetch" href="/vssue-comment/assets/js/6.0cbbe057.js"><link rel="prefetch" href="/vssue-comment/assets/js/7.feaf1269.js"><link rel="prefetch" href="/vssue-comment/assets/js/8.9c40e8a4.js"><link rel="prefetch" href="/vssue-comment/assets/js/9.b2c8bfda.js"><link rel="prefetch" href="/vssue-comment/assets/js/vuejs-paginate.8412c6fc.js">
    <link rel="stylesheet" href="/vssue-comment/assets/css/0.styles.02c2761a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/vssue-comment/" class="nav-link home-link">Ni's Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/vssue-comment/" class="nav-link mobile-home-link">Ni's Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Java 多线程基础
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Ni</span> <span itemprop="address">   in 大连</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-06-27 12:00:00+0800">
      Sun Jun 27 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/vssue-comment/tag/Java" data-v-42ccfcd5><span data-v-42ccfcd5>Java</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>多线程是 Java 最基本的并发模型。</p> <p>线程做为操作系统调度的最小单元，多个线程同时执行，显著提高了程序的执行性能。但是对线程的不当管理很容易造成其他的问题。</p> <p>将通过一下内容介绍 Java 多线程的基础：</p> <ul><li>线程及线程的构造</li> <li>线程的状态</li> <li>线程间的通信 —— 等待/通知机制</li> <li>ThreadLocal 变量</li></ul> <p>目录：</p> <div><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-线程简介">1. 线程简介</a><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-1-上下文切换">1.1 上下文切换</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-2-线程是什么">1.2 线程是什么</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-3-为什么用线程">1.3 为什么用线程</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-4-线程优先级">1.4 线程优先级</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_1-5-守护线程-daemon-thread">1.5 守护线程（Daemon Thread）</a></li></ul></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-线程基本方法">2. 线程基本方法</a><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-1-线程的构造">2.1 线程的构造</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-2-创建线程">2.2 创建线程</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-3-线程-start-启动">2.3 线程 start —— 启动</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-4-线程-interupt-中断">2.4 线程 interupt —— 中断</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-5-线程的过期操作">2.5 线程的过期操作</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-6-线程-yield-让出-cpu-资源">2.6 线程 yield —— 让出 CPU 资源</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-7-线程-sleep-睡眠">2.7 线程 sleep —— 睡眠</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-8-线程-join">2.8 线程 join</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_2-9-线程安全终止">2.9 线程安全终止</a></li></ul></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_3-线程的状态">3. 线程的状态</a><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_3-1-线程的状体">3.1 线程的状体</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_3-2-线程状态转换">3.2 线程状态转换</a></li></ul></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_4-线程间通信">4. 线程间通信</a><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_4-1-volatile-与-synchronized">4.1 volatile 与 synchronized</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_4-2-线程的等待与通知">4.2 线程的等待与通知</a></li></ul></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_5-线程变量-threadlocal">5. 线程变量（ThreadLocal ）</a><ul><li><a href="/vssue-comment/2021/06/27/_00-thread/#_5-1-threadlocal-基础结构">5.1 ThreadLocal 基础结构</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_5-2-threadlocal-原理">5.2 ThreadLocal 原理</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_5-3-threadlocal-内存泄漏">5.3 ThreadLocal 内存泄漏</a></li><li><a href="/vssue-comment/2021/06/27/_00-thread/#_5-4-java-中的四种引用">5.4 Java 中的四种引用</a></li></ul></li></ul></div> <h2 id="_1-线程简介"><a href="#_1-线程简介" class="header-anchor">#</a> 1. 线程简介</h2> <h3 id="_1-1-上下文切换"><a href="#_1-1-上下文切换" class="header-anchor">#</a> 1.1 上下文切换</h3> <p>并发编程的目的是为了更高效的使用 CPU，从而使程序运行更快。但是启动更多的线程就会面临更多的问题，最显著的就是上下文切换。</p> <h4 id="_1-1-1-上下文切换是什么"><a href="#_1-1-1-上下文切换是什么" class="header-anchor">#</a> 1.1.1 上下文切换是什么</h4> <p>CPU 通过给每个线程分配 CPU 时间片来实现多线程处理。</p> <p>时间片是 CPU 分配给各个线程的执行时间。由于时间片非常短（一般是几时毫秒 ms），所以 CPU 通过不停的切换线程执行，让我们感觉多个线程是同时执行的。</p> <p>CPU 通过时间片分配算法来循环执行任务，在任务切换前会保存上一个任务的状态，以便下次切换回这个任务的时，可以再次加载这个任务的状态。<strong>任务从保存到再次加载的过程就是一次上下文切换</strong>。</p> <h4 id="_1-1-2-减少上下文切换的方法"><a href="#_1-1-2-减少上下文切换的方法" class="header-anchor">#</a> 1.1.2 减少上下文切换的方法</h4> <p><strong>过多的上下文切换会导致性能问题</strong>。</p> <p>根据 Tsuna 的测试报告，每次上下文切换都需要占用 CPU 几十纳秒到数微秒的时间。这个时间对 CPU 来说相当可观，特别是上下文切换次数较多的情况下，很容易导致大量的时间耗费在线程状态的保存和恢复上，进而缩短了程序真正运行的时间。影响多线程执行效率，导致平均负载升高。</p> <p>减少上下文切换的方法：</p> <ul><li>无锁并发编程：将数据 ID 按照 Hash 算法取模分段，不同的线程执行不同的数据。</li> <li>CAS 算法：Java 的 <code>Atomic</code> 包使用 CAS 算法更新数据。</li> <li>使用最少线程：避免创建不需要的线程。</li> <li>使用协程：在单线程中实现多任务调度，并在单线程中维持多个任务间的切换。</li></ul> <h3 id="_1-2-线程是什么"><a href="#_1-2-线程是什么" class="header-anchor">#</a> 1.2 线程是什么</h3> <p>现代操作系统运行一个程序时，就会为其创建一个进程。例如，启动一个 Java 程序，操作系统就会创建一个 Java 进程。</p> <p>现代<strong>操作系统调度的最小单位是线程</strong>，也叫轻量级进程，在一个进程里面可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够快速访问共享内存的变量。</p> <p>一个 Java 程序从 main 方法开始执行，然后按照既定的代码逻辑执行，看似没有其他的线程参与，但实际上是有 main 线程和其他多个线程同时运行，最基本的：</p> <ul><li>main：主线程，程序入口</li> <li>Reference Handle：清除引用的线程</li> <li>Finalizer：调用对象 finalize 方法的线程</li> <li>Signal Dispatcher：分发处理发送给 JVM 信号的线程</li></ul> <h3 id="_1-3-为什么用线程"><a href="#_1-3-为什么用线程" class="header-anchor">#</a> 1.3 为什么用线程</h3> <p>正确使用多线程，能够带来显著的好处：</p> <ol><li>更多的处理器核心，提高程序执行效率。</li> <li>更快的响应时间，提升用户体验。</li> <li>更好的编程模型，使开发人员专注于问题的解决。</li></ol> <h3 id="_1-4-线程优先级"><a href="#_1-4-线程优先级" class="header-anchor">#</a> 1.4 线程优先级</h3> <p>线程分配到时间片的多少决定了线程使用处理器资源的多少，而线程使用到 CPU 资源的多少决定了线程的优先级。</p> <p>在 Java 程序中通过一个整型变量 <code>priority</code> 来控制优先级，范围 1～ 10，可以通过 <code>setPriority(int)</code> 来修改优先级，默认是 5。优先级越高，分配的时间片越多。</p> <blockquote><p>不同的操作系统，对线程优先级的响应不同。Mac OS 可能会直接忽略优先级，所有 Java 优先级均为 5（通过 jstack 命令查看）。</p></blockquote> <h3 id="_1-5-守护线程-daemon-thread"><a href="#_1-5-守护线程-daemon-thread" class="header-anchor">#</a> 1.5 守护线程（Daemon Thread）</h3> <h4 id="_1-5-1-守护线程是什么"><a href="#_1-5-1-守护线程是什么" class="header-anchor">#</a> 1.5.1 守护线程是什么</h4> <p><strong>守护线程是为其他线程服务的线程</strong>，是一种支持型线程。</p> <p>在 Java 程序中，就是由 JVM 启动 <code>main</code> 线程，<code>main</code> 线程启动其他线程。当所有线程运行结束，JVM 退出，进程结束。</p> <p>如果有一个线程没有退出，JVM 进程就不会结束。所以必须保证所有线程都能及时结束。</p> <p>但是，有一种线程目的就是无限循环，比如监听程序状态的线程。如果这个线程不结束，JVM 进程就无法结束。</p> <p>问题是，由谁负责结束这个线程？然而这类线程经常没有负责人来负责结束它们，但是其他线程结束时，JVM 进程必须结束，怎么办？</p> <p>答案是守护线程（Daemon Thread）。</p> <p>在 JVM 中所有非守护线程都执行完毕后，无论是否有守护线程，JVM 都会自动退出，结束 JVM 进程。此时，守护线程自动销毁。</p> <blockquote><p>⚠️守护线程不能持有任何需要关闭的资源，例如打开文件等，因为 JVM 退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p></blockquote> <h4 id="_1-5-2-守护线程的创建"><a href="#_1-5-2-守护线程的创建" class="header-anchor">#</a> 1.5.2 守护线程的创建</h4> <p>在调用 <code>start()</code> 方法前，调用 <code>setDaemon(true)</code>，把该线程标记为守护线程。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>⚠️守护线程需要在线程启动之前设置，不能再启动之后设置。</p></blockquote> <h4 id="_1-5-3-守护线程的作用"><a href="#_1-5-3-守护线程的作用" class="header-anchor">#</a> 1.5.3 守护线程的作用</h4> <ul><li>事件监听</li> <li>定时任务</li> <li>心跳检测</li> <li>GC 回收</li></ul> <h2 id="_2-线程基本方法"><a href="#_2-线程基本方法" class="header-anchor">#</a> 2. 线程基本方法</h2> <h3 id="_2-1-线程的构造"><a href="#_2-1-线程的构造" class="header-anchor">#</a> 2.1 线程的构造</h3> <p>在运行一个线程之前，首先要构造线程对象。</p> <p>线程属性参考以下 Thread 构造方法（有删减）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">ThreadGroup</span> g<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> target<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>
                   <span class="token keyword">long</span> stackSize<span class="token punctuation">,</span> <span class="token class-name">AccessControlContext</span> acc<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> inheritThreadLocals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">&quot;name cannot be null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token comment">// 当前线程就是新创建线程的父线程</span>
  <span class="token class-name">Thread</span> parent <span class="token operator">=</span> <span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>group <span class="token operator">=</span> g<span class="token punctuation">;</span>
  <span class="token comment">// 将 daemon、priority、contextClassLoader、</span>
  <span class="token comment">// inheritThreadLocals属性设置为父线程的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>daemon <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>security <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">isCCLOverridden</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span>contextClassLoader<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>inheritedAccessControlContext <span class="token operator">=</span>
    acc <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> acc <span class="token operator">:</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
  <span class="token function">setPriority</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>
    <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Stash the specified stack size in case the VM cares */</span>
  <span class="token comment">// 分配栈内存大小</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stackSize <span class="token operator">=</span> stackSize<span class="token punctuation">;</span>

  <span class="token comment">// 分配一个线程 ID</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tid <span class="token operator">=</span> <span class="token function">nextThreadID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此一个可运行的线程构造完成，在堆内存中等待运行。</p> <h3 id="_2-2-创建线程"><a href="#_2-2-创建线程" class="header-anchor">#</a> 2.2 创建线程</h3> <p>两种方式：</p> <ol><li>继承 Thread 类</li> <li>实现 Runnable 接口</li></ol> <h3 id="_2-3-线程-start-启动"><a href="#_2-3-线程-start-启动" class="header-anchor">#</a> 2.3 线程 start —— 启动</h3> <p>其他线程通过调用该线程的 start() 方法，启动该线程。</p> <blockquote><p>start 方法的含义是：调用 start() 方法的线程告诉 JVM，只要线程规划器空闲，应立即启动调用创建的线程。</p></blockquote> <h3 id="_2-4-线程-interupt-中断"><a href="#_2-4-线程-interupt-中断" class="header-anchor">#</a> 2.4 线程 interupt —— 中断</h3> <p>其他线程通过调用该线程的 interrupt() 方法，中断该线程。</p> <p>其他线程通过调用该线程的 isInterrupted() 方法，判断该线程是否被中断。不会清除中断标识位。</p> <p>也可以调用静态方法 Thread.interrupted() 方法，判断该线程是否被中断。会清除中断标识位。</p> <blockquote><p>仅仅设置线程的中断标识位，并不会停止线程。</p></blockquote> <h3 id="_2-5-线程的过期操作"><a href="#_2-5-线程的过期操作" class="header-anchor">#</a> 2.5 线程的过期操作</h3> <p>以下对线程的 3 个操作已经标注为过期，不建议使用。</p> <p>suspend() 暂停线程、resume() 恢复线程、stop() 停止线程</p> <blockquote><p>不建议使用的原用：</p> <p>在 suspend() 方法调用后，线程不会释放已经占有的资源（比如锁），而是占有资源进入睡眠状态，容易引发思索的问题。</p> <p>在 stop() 方法调用后，不会保证线程资源的正常释放，因此导致线程状态不确定。</p></blockquote> <h3 id="_2-6-线程-yield-让出-cpu-资源"><a href="#_2-6-线程-yield-让出-cpu-资源" class="header-anchor">#</a> 2.6 线程 yield —— 让出 CPU 资源</h3> <p>yield() 方法，表示资源放弃当前已经获取的 CPU 资源。如果 CPU 资源不紧张，则会忽略这个操作。</p> <h3 id="_2-7-线程-sleep-睡眠"><a href="#_2-7-线程-sleep-睡眠" class="header-anchor">#</a> 2.7 线程 sleep —— 睡眠</h3> <p>Thread.sleep(long) 方法，使当前线程进入休眠，暂停执行。休眠时不会放弃已经获得的锁。</p> <p>建议使用 TimeUnit 类替换 sleep() 方法，它提供了更好的封装。</p> <p>TimeUnit.SECONDS.sleep(long)</p> <p>TimeUnit.MILLISECONDS.sleep(long)</p> <h3 id="_2-8-线程-join"><a href="#_2-8-线程-join" class="header-anchor">#</a> 2.8 线程 join</h3> <p>在线程 B 执行时，join 某个线程A，会使当前线程 B 进入等待，直到线程 A 执行结束或者到达指定的时间，从 join 方法返回，线程 B 继续执行。</p> <p>响应超时的两个方法：<code>join(long millis)</code>、<code>join(long millis, int nanos)</code></p> <h3 id="_2-9-线程安全终止"><a href="#_2-9-线程安全终止" class="header-anchor">#</a> 2.9 线程安全终止</h3> <ol><li>线程结束生命周期，正常执行完毕</li> <li>捕获中断信号关闭线程</li> <li>使用 volatile 开关控制</li></ol> <h2 id="_3-线程的状态"><a href="#_3-线程的状态" class="header-anchor">#</a> 3. 线程的状态</h2> <h3 id="_3-1-线程的状体"><a href="#_3-1-线程的状体" class="header-anchor">#</a> 3.1 线程的状体</h3> <p>Java 线程在运行的生命周期中可能会处于 6 中不同的状态，在某一时刻，线程只能处于其中一个状态。</p> <table><thead><tr><th>状态</th> <th>说明</th></tr></thead> <tbody><tr><td>New 初始状态</td> <td>表示线程被构建，但还没有调用 start() 方法</td></tr> <tr><td>Runnable 可运行状态</td> <td>Java 线程将操作系统中的就绪和运行中两种状态统称为 “可运行”</td></tr> <tr><td>Blocked 阻塞状态</td> <td>表示线程阻塞于锁</td></tr> <tr><td>Waiting 等待状态</td> <td>表示当前线程需要等待其他线程做出一些特定动作（通知、中断）</td></tr> <tr><td>Timed_Waiting 超时等待状态</td> <td>区别于等待状态，该状态可以在指定时间自行返回</td></tr> <tr><td>Terminated 终止状态</td> <td>表示当前线程执行完毕</td></tr></tbody></table> <blockquote><p>可以使用 jstack 工具查看代码运行时的线程状态信息。</p> <p>先使用 top 命令定位到 Java 程序对应的进程 ID，然后再键入 <code>jstack $ID</code> 即可查看线程状态信息。</p></blockquote> <h3 id="_3-2-线程状态转换"><a href="#_3-2-线程状态转换" class="header-anchor">#</a> 3.2 线程状态转换</h3> <p><img src="/vssue-comment/assets/img/thread_state.a646883e.png" alt=""></p> <blockquote><p>⚠️</p> <ol><li>阻塞状态是线程阻塞在进入 <code>synchronized</code> 关键字修饰的方法或者代码块时的状态，但是阻塞在 <code>java.concurrent</code> 包中 <code>Lock</code> 接口的线程却是等待状态，因为 <code>java.concurrent</code> 包中 <code>Lock</code> 接口对于阻塞的实现均使用了 <code>LockSupport</code> 类中的方法。</li> <li>阻塞线程在同步队列中阻塞。对应 Blocked 状态。</li> <li>等待线程在等待队列中等待，当等待线程被唤醒后，进入同步队列尝试获取锁。对应 Waiting、Timed_Waiting 状态。</li></ol></blockquote> <h2 id="_4-线程间通信"><a href="#_4-线程间通信" class="header-anchor">#</a> 4. 线程间通信</h2> <h3 id="_4-1-volatile-与-synchronized"><a href="#_4-1-volatile-与-synchronized" class="header-anchor">#</a> 4.1 volatile 与 synchronized</h3> <p>多个线程相互配合完成工作，将会带来巨大的价值，这就需要用到线程间通信。</p> <ul><li>关键字 volatile 修饰成员变量，用来告知程序任何对该变量的访问均需要从共享内存中获取，对该变量的修改必须同步刷新回共享内存。它保证了所有线程对变量访问的可见性和有序性。</li> <li>修饰符 synchronized 修饰方法或者代码块，用来确保多个线程在同一时刻，只能有一个线程处于方法或同步块中。它保证了线程对代码执行的可见性、有序性和原子性。</li></ul> <blockquote><p>可以使用 javap 工具生成 class 文件信息，分析 synchronized 关键字实现细节。</p> <p>synchronized 实现原理、对象与对象 monitor 详看其他文章。</p></blockquote> <h3 id="_4-2-线程的等待与通知"><a href="#_4-2-线程的等待与通知" class="header-anchor">#</a> 4.2 线程的等待与通知</h3> <p>一个线程修改了一个对象的值，另一个线程需要感知这种变化，然后做出响应的操作。前一个线程为生产者，后一个线程就是消费者。这种模式实现了解耦，具备良好的伸缩性。</p> <p>该模式一种简单的实现方式是：让消费者线程不断循环检查对象是否符合预期，若不满足条件时，可使线程睡眠一段时间，然后继续循环。该实现方式的缺点显而易见：</p> <ol><li>睡眠过长，难以确保及时操作。</li> <li>睡眠过短，难以降低 CPU 开销。</li></ol> <p>另一种实现方式，则很好的解决了这个看似难以调和的矛盾。Java 通过内置等待/通知机制依托于同步机制（synchronized）很好的实现该模式。</p> <h4 id="_4-2-1-等待通知方法"><a href="#_4-2-1-等待通知方法" class="header-anchor">#</a> 4.2.1 等待通知方法</h4> <p>等待/通知的相关方法被定义在对象的超类 java.lang.Object 上，所以任意 Java 对象都具备这个方法：</p> <table><thead><tr><th>方法名称</th> <th>描述</th></tr></thead> <tbody><tr><td>wait()</td> <td>使线程进入 Waiting 状态，只有其他线程通知或中断该线程才会从该方法返回。<br>调用该方法后，释放对象的锁。</td></tr> <tr><td>wait(long)</td> <td>同上，响应超时。单位是毫秒。</td></tr> <tr><td>wait(long, int)</td> <td>同上，单位可以达到纳秒。</td></tr> <tr><td>notify()</td> <td>通知一个等待线程，使线程从 wait() 方法返回。<br>返回的前提是该线程获取到了对象的锁。</td></tr> <tr><td>notifyAll()</td> <td>同上，通知所有等待线程。</td></tr></tbody></table> <blockquote><p>⚠️</p> <ol><li>使用以上方式时，需要先对调用对象加锁（同步方法或同步块内使用）。</li> <li>调用 <code>wait()</code> 方法后，线程由 Runnable 状态变为 Waiting 状态，线程被放置到对象的等待队列中。</li> <li><code>notify</code> 相关方法调用后，等待线程不会立即从 <code>wait</code> 相关方法返回，需要调用 <code>notify</code> 相关方法的线程释放锁之后，等待线程才有机会返回。</li> <li><code>notify()</code> 方法将等待队列中的一个等待线程从等待队列中移动到同步队列中，<code>notifyAll()</code> 方法将等待队列中所有线程移动到同步队列中。被移动的线程从 Waiting 状态变为 Blocked 状态。</li> <li><code>wait</code> 相关方法返回前提是获得了调用对象的锁。</li></ol></blockquote> <p>可以看出，等待/通知机制依托于同步机制，目的是确保等待线程从 wait 相关方法返回时能够感知到通知线程对变量做出的修改。</p> <p><img src="/vssue-comment/assets/img/wait_notify.c1110bda.png" alt=""></p> <p>上图中，Wait Thread 首先获取对象锁，然后调用<code>wait()</code> 方法放弃锁，并进入等待队列。由于 Wait Thread 线程释放了锁，Notify Thread 随后获取锁，执行自己的任务并调用 <code>notify()</code> 方法，将 Wait Thread 从等待队列移到同步队列中，此时 Wait Thread 状态变为 Blocked 状态。等待 Notify Thread 执行完任务并释放锁之后，Wait Thread 重新获取锁，从 <code>wait()</code> 方法返回并继续向下执行。</p> <h4 id="_4-2-2-等待-通知经典范式"><a href="#_4-2-2-等待-通知经典范式" class="header-anchor">#</a> 4.2.2 等待/通知经典范式</h4> <p>该范式包含两部分，分别针对等待方（消费者）和通知方（生产者）。</p> <ul><li><p>等待方：</p> <ol><li>首先进入同步方法或同步块，获取对象的锁。</li> <li>如果条件不满足，调用对象的 wait 方法，释放锁并进入等待队列，被通知后仍要检查条件。</li> <li>条件满足则执行对应的处理逻辑。</li></ol> <p>伪代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  对应的处理逻辑
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通知方：</p> <ol><li>首先进入同步方法或同步块，获取对象的锁。</li> <li>改变条件</li> <li>通知等待在对象上的线程</li></ol> <p>伪代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  改变条件
  object<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_5-线程变量-threadlocal"><a href="#_5-线程变量-threadlocal" class="header-anchor">#</a> 5. 线程变量（ThreadLocal ）</h2> <p>线程变量（ThreadLocal），它不是一个 Thread，而是 ThreadLocalVariable，即线程局部变量。在多线程环境下，它可以保证各个线程之间的变量相互独立。</p> <p>ThreadLocal 本质就是变量，一切思考要从变量的角度去想问题，而不是从线程的角度考虑问题。</p> <h3 id="_5-1-threadlocal-基础结构"><a href="#_5-1-threadlocal-基础结构" class="header-anchor">#</a> 5.1 ThreadLocal 基础结构</h3> <p>ThreadLocal 是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是一个线程可以根据该线程的 ThreadLocal 对象查询到绑定在这个线程上的一个值。</p> <ul><li><p>通过 set 方法设置当前线程的局部变量值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通过 get 方法获取原先设置的当前线程的局部变量值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前线程</span>
  <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 每个线程都有自己的 ThreadLocalMap</span>
  <span class="token comment">// ThreadLocalMap 里保存着所有的 ThreadLocal 变量</span>
  <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前 ThreadLocal 对象实例就是 ThreadLocalMap 的 key</span>
    <span class="token comment">// ThreadLocal 变量的值都是放在这个 Map 中的</span>
    <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
      <span class="token comment">// 从 Map 里取出来的值就是我们需要的这个ThreadLocal变量</span>
      <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果 Map 是 null，那么初始化</span>
  <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通过 remove 方法删除当前线程的局部变量值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>通过 withInitial 静态方法创建一个 ThreadLocal</p></li></ul> <p>使用示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strLabel<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> threadLabel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strLabel <span class="token operator">=</span> <span class="token string">&quot;main&quot;</span><span class="token punctuation">;</span>
        threadLabel<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;main&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                strLabel <span class="token operator">=</span> <span class="token string">&quot;child&quot;</span><span class="token punctuation">;</span>
                threadLabel<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;child&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 保证线程执行完毕</span>
            thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;strLabel = &quot;</span> <span class="token operator">+</span> strLabel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;threadLabel = &quot;</span> <span class="token operator">+</span> threadLabel<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行结果：</p> <div class="language-java extra-class"><pre class="language-java"><code>strLabel <span class="token operator">=</span> child
threadLabel <span class="token operator">=</span> main
</code></pre></div><p>从运行结果可以看出，对于 ThreadLocal 类型的变量，在一个线程中设置值，不影响其在其它线程中的值。也就是说 ThreadLocal 类型的变量的值在每个线程中是独立的。</p> <h3 id="_5-2-threadlocal-原理"><a href="#_5-2-threadlocal-原理" class="header-anchor">#</a> 5.2 ThreadLocal 原理</h3> <p>在 ThreadLocal 类中有一个 ThreadLocalMap，用于存储每一个线程的变量副本，Map 中元素的键为 ThreadLocal 对象，而值对应线程的变量副本。</p> <p>ThreadLocal.ThreadLocalMap 是一个比较特殊的 Map，它的每个 Entry 的 key 都是一个弱引用。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/** The value associated with this ThreadLocal. */</span>
  <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

  <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// key 为弱引用，value 依然为强引用。</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    value <span class="token operator">=</span> v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-3-threadlocal-内存泄漏"><a href="#_5-3-threadlocal-内存泄漏" class="header-anchor">#</a> 5.3 ThreadLocal 内存泄漏</h3> <p>虽然 ThreadLocalMap 中的 Key 是弱引用，当 GC 发生的时候，就会自动被回收，但是 Entry 中的 Value 依然是强引用。</p> <p>只有当 Thread 被回收时，这个 Value 才有被回收的机会，否则，只要线程不退出，Value 总是会存在一个强引用。但是，要求每个Thread 都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造 Value 对象出现泄漏的可能。</p> <p>解决办法：<strong>当你不需要这个 ThreadLocal 变量时，主动调用 remove()</strong>。</p> <h3 id="_5-4-java-中的四种引用"><a href="#_5-4-java-中的四种引用" class="header-anchor">#</a> 5.4 Java 中的四种引用</h3> <h4 id="_5-4-1-强引用-strong-reference"><a href="#_5-4-1-强引用-strong-reference" class="header-anchor">#</a> 5.4.1 强引用（Strong Reference）</h4> <p>默认的引用对象都是强引用类型。</p> <ul><li>如果JVM垃圾回收器 GC 可达性分析结果为可达，表示引用类型仍然被引用着，这类对象始终不会被垃圾回收器回收，即使 JVM 发生 OOM 也不会回收。</li> <li>而如果 GC 的可达性分析结果为不可达，那么在GC时会被回收。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> web <span class="token operator">=</span> <span class="token string">&quot;www.threadlocal.cn&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_5-4-2-软引用-soft-reference"><a href="#_5-4-2-软引用-soft-reference" class="header-anchor">#</a> 5.4.2 软引用（Soft Reference）</h4> <p>软引用是一种比强引用生命周期稍弱的一种引用类型。一般用来实现内存敏感的缓存。</p> <ul><li>在 JVM 内存充足的情况下，软引用并不会被垃圾回收器回收。</li> <li>只有在 JVM 内存不足的情况下，才会被垃圾回收器回收。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;www.threadlocal.cn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> web <span class="token operator">=</span> softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_5-4-3-弱引用-weak-reference"><a href="#_5-4-3-弱引用-weak-reference" class="header-anchor">#</a> 5.4.3 弱引用（Weak Reference）</h4> <p>弱引用是一种比软引用生命周期更短的引用。在使用虚引用时，必须和引用队列关联使用。</p> <p>在对象的垃圾回收过程中，如果GC发现一个对象还存在虚引用，则会把这个虚引用加入到与之关联的引用队列中。</p> <p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p> <ul><li>不论当前内存是否充足，都只能存活到下一次垃圾收集之前。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;www.threadlocal.cn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>weakReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;weakReference已经被GC回收&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_5-4-4-虚引用-phantom-reference"><a href="#_5-4-4-虚引用-phantom-reference" class="header-anchor">#</a> 5.4.4 虚引用（Phantom Reference）</h4> <p>虚引用与前面的几种都不一样，这种引用类型不会影响对象的生命周期，所持有的引用就跟没持有一样。</p> <ul><li>随时都能被 GC 回收。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;www.threadlocal.cn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-线程简介" title="1. 线程简介">1. 线程简介</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-1-上下文切换" title="1.1 上下文切换">1.1 上下文切换</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-2-线程是什么" title="1.2 线程是什么">1.2 线程是什么</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-3-为什么用线程" title="1.3 为什么用线程">1.3 为什么用线程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-4-线程优先级" title="1.4 线程优先级">1.4 线程优先级</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-5-守护线程-daemon-thread" title="1.5 守护线程（Daemon Thread）">1.5 守护线程（Daemon Thread）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-线程基本方法" title="2. 线程基本方法">2. 线程基本方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-1-线程的构造" title="2.1 线程的构造">2.1 线程的构造</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-2-创建线程" title="2.2 创建线程">2.2 创建线程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-3-线程-start-启动" title="2.3 线程 start —— 启动">2.3 线程 start —— 启动</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-4-线程-interupt-中断" title="2.4 线程 interupt —— 中断">2.4 线程 interupt —— 中断</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-5-线程的过期操作" title="2.5 线程的过期操作">2.5 线程的过期操作</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-6-线程-yield-让出-cpu-资源" title="2.6 线程 yield —— 让出 CPU 资源">2.6 线程 yield —— 让出 CPU 资源</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-7-线程-sleep-睡眠" title="2.7 线程 sleep —— 睡眠">2.7 线程 sleep —— 睡眠</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-8-线程-join" title="2.8 线程 join">2.8 线程 join</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-9-线程安全终止" title="2.9 线程安全终止">2.9 线程安全终止</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-线程的状态" title="3. 线程的状态">3. 线程的状态</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-线程的状体" title="3.1 线程的状体">3.1 线程的状体</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-线程状态转换" title="3.2 线程状态转换">3.2 线程状态转换</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_4-线程间通信" title="4. 线程间通信">4. 线程间通信</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-1-volatile-与-synchronized" title="4.1 volatile 与 synchronized">4.1 volatile 与 synchronized</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-2-线程的等待与通知" title="4.2 线程的等待与通知">4.2 线程的等待与通知</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_5-线程变量-threadlocal" title="5. 线程变量（ThreadLocal ）">5. 线程变量（ThreadLocal ）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-1-threadlocal-基础结构" title="5.1 ThreadLocal 基础结构">5.1 ThreadLocal 基础结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-2-threadlocal-原理" title="5.2 ThreadLocal 原理">5.2 ThreadLocal 原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-3-threadlocal-内存泄漏" title="5.3 ThreadLocal 内存泄漏">5.3 ThreadLocal 内存泄漏</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-4-java-中的四种引用" title="5.4 Java 中的四种引用">5.4 Java 中的四种引用</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>Privacy Policy</a></li><li class="copyright-item" data-v-3d9deeb8>MIT Licensed | Copyright © 2018-present Vue.js</li></ul></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/vssue-comment/assets/js/app.9fa4f4bb.js" defer></script><script src="/vssue-comment/assets/js/13.044f1fde.js" defer></script><script src="/vssue-comment/assets/js/3.f0de84e7.js" defer></script><script src="/vssue-comment/assets/js/18.02aac107.js" defer></script>
  </body>
</html>
