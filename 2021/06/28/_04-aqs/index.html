<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>AQS 及其锁的实现原理 | Ni&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="$page.excerpt">
    
    <link rel="preload" href="/vssue-comment/assets/css/0.styles.02c2761a.css" as="style"><link rel="preload" href="/vssue-comment/assets/js/app.9fa4f4bb.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/13.044f1fde.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/3.f0de84e7.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/9.b2c8bfda.js" as="script"><link rel="prefetch" href="/vssue-comment/assets/js/10.23cc3d6b.js"><link rel="prefetch" href="/vssue-comment/assets/js/11.c63e2dcc.js"><link rel="prefetch" href="/vssue-comment/assets/js/12.d7671ee7.js"><link rel="prefetch" href="/vssue-comment/assets/js/14.399fc32e.js"><link rel="prefetch" href="/vssue-comment/assets/js/15.37bef016.js"><link rel="prefetch" href="/vssue-comment/assets/js/16.2ae3cc61.js"><link rel="prefetch" href="/vssue-comment/assets/js/17.10c0352f.js"><link rel="prefetch" href="/vssue-comment/assets/js/18.02aac107.js"><link rel="prefetch" href="/vssue-comment/assets/js/19.ac0b8b1d.js"><link rel="prefetch" href="/vssue-comment/assets/js/20.656ccc17.js"><link rel="prefetch" href="/vssue-comment/assets/js/21.d1f01d1a.js"><link rel="prefetch" href="/vssue-comment/assets/js/22.6e251d71.js"><link rel="prefetch" href="/vssue-comment/assets/js/23.caaa7b12.js"><link rel="prefetch" href="/vssue-comment/assets/js/24.33d428f1.js"><link rel="prefetch" href="/vssue-comment/assets/js/25.207f6b5f.js"><link rel="prefetch" href="/vssue-comment/assets/js/26.398d8fee.js"><link rel="prefetch" href="/vssue-comment/assets/js/27.d4ae83e5.js"><link rel="prefetch" href="/vssue-comment/assets/js/28.66c58624.js"><link rel="prefetch" href="/vssue-comment/assets/js/29.a6686645.js"><link rel="prefetch" href="/vssue-comment/assets/js/30.242e18b7.js"><link rel="prefetch" href="/vssue-comment/assets/js/31.7da4eecc.js"><link rel="prefetch" href="/vssue-comment/assets/js/32.9b8f3ea0.js"><link rel="prefetch" href="/vssue-comment/assets/js/33.075dbe36.js"><link rel="prefetch" href="/vssue-comment/assets/js/34.838ce186.js"><link rel="prefetch" href="/vssue-comment/assets/js/35.3bbd155f.js"><link rel="prefetch" href="/vssue-comment/assets/js/36.a07ab564.js"><link rel="prefetch" href="/vssue-comment/assets/js/37.50ef72a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/38.75b498ed.js"><link rel="prefetch" href="/vssue-comment/assets/js/39.3b1e3afb.js"><link rel="prefetch" href="/vssue-comment/assets/js/4.79c2a3ee.js"><link rel="prefetch" href="/vssue-comment/assets/js/40.0a6fdf1b.js"><link rel="prefetch" href="/vssue-comment/assets/js/41.9be8ec60.js"><link rel="prefetch" href="/vssue-comment/assets/js/42.9ce4d2b3.js"><link rel="prefetch" href="/vssue-comment/assets/js/43.c76f9c55.js"><link rel="prefetch" href="/vssue-comment/assets/js/44.4749cc3b.js"><link rel="prefetch" href="/vssue-comment/assets/js/45.605778e4.js"><link rel="prefetch" href="/vssue-comment/assets/js/46.fd2913a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/47.5b787534.js"><link rel="prefetch" href="/vssue-comment/assets/js/48.7cf6064e.js"><link rel="prefetch" href="/vssue-comment/assets/js/49.ffa11e3d.js"><link rel="prefetch" href="/vssue-comment/assets/js/5.6a98c4eb.js"><link rel="prefetch" href="/vssue-comment/assets/js/50.69284de8.js"><link rel="prefetch" href="/vssue-comment/assets/js/6.0cbbe057.js"><link rel="prefetch" href="/vssue-comment/assets/js/7.feaf1269.js"><link rel="prefetch" href="/vssue-comment/assets/js/8.9c40e8a4.js"><link rel="prefetch" href="/vssue-comment/assets/js/vuejs-paginate.8412c6fc.js">
    <link rel="stylesheet" href="/vssue-comment/assets/css/0.styles.02c2761a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/vssue-comment/" class="nav-link home-link">Ni's Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/vssue-comment/" class="nav-link mobile-home-link">Ni's Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        AQS 及其锁的实现原理
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Ni</span> <span itemprop="address">   in 大连</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-06-28 15:00:00+0800">
      Mon Jun 28 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/vssue-comment/tag/Java" data-v-42ccfcd5><span data-v-42ccfcd5>Java</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>同步器是实现锁的关键。可以这么理解同步器与锁的关系：锁是面向使用者的，它定义了使用者与锁交换的接口，隐藏了实现细节；同步器面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、线程等待与通知等底层操作。</p> <p>队列同步器（AbstractQueuedSynchronized，AQS），是用来构建锁和其他同步组件的基础框架，它使用了一个整型（int）成员变量表示同步状态，通过内置的 FIFO 队列来完成线程的排队工作。</p> <p>将通过以下内容详解同步器及其锁的实现原理：</p> <ul><li>AQS 类 —— <strong>Java 并发编程的基石</strong>。</li> <li>Lock 接口 —— Lock 接口的实现类基本都是通过聚合了一个同步器的子类来完成线程访问控制。</li> <li>独占锁（例 ReentrantLock） —— 它允许同一时刻只能有一个线程获取锁。</li> <li>共享锁（例 ReentrantReadWriteLock） —— 它允许同一时刻有多个线程获取锁。</li> <li>LockSupport 工具 —— 它定义了一组公共的静态方法，提供了最基本的线程阻塞和唤醒功能。</li> <li>Condition 接口 —— 它为 Lock 提供的监视器方法，以实现等待/通知模式。</li></ul> <p>JUC 中的 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code> 和 <code>Semaphore</code> 等同步工具都是基于 AQS 实现的。</p> <p>目录：</p> <div><ul><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-aqs">1. AQS</a><ul><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-1-lock-接口">1.1 Lock 接口</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-2-队列同步器-abstractqueuedsynchronizer-aqs">1.2  队列同步器（AbstractQueuedSynchronizer，AQS）</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-3-同步队列">1.3 同步队列</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-4-同步器的独占模式">1.4 同步器的独占模式</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-5-同步器的共享模式">1.5 同步器的共享模式</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_1-6-同步器的独占式超时模式">1.6 同步器的独占式超时模式</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_2-独占锁-不可重入-mutex">2. 独占锁（不可重入） —— Mutex</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_3-独占锁-可重入-reentrantlock">3. 独占锁（可重入） —— ReentrantLock</a><ul><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_3-1-实现可重入">3.1 实现可重入</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_3-2-公平与非公平的区别">3.2 公平与非公平的区别</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_3-3-测试可重入">3.3 测试可重入</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-共享锁-读写锁-reentrantreadwritelock">4. 共享锁 —— 读写锁（ReentrantReadWriteLock）</a><ul><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-1-readwritelock-接口">4.1 ReadWriteLock 接口</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-2-读写锁状态设计">4.2 读写锁状态设计</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-3-写锁的获取与释放">4.3 写锁的获取与释放</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-4-读锁的获取与释放">4.4 读锁的获取与释放</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_4-5-锁降级">4.5 锁降级</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_5-locksupport-工具">5. LockSupport 工具</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_6-condition-接口">6. Condition 接口</a><ul><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_6-1-常用方法">6.1 常用方法</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_6-2-使用方式">6.2 使用方式</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_6-3-等待队列">6.3 等待队列</a></li><li><a href="/vssue-comment/2021/06/28/_04-aqs/#_6-4-synchronized-监视器与-condition-对比">6.4 Synchronized 监视器与 Condition 对比</a></li></ul></li></ul></div> <h2 id="_1-aqs"><a href="#_1-aqs" class="header-anchor">#</a> 1. AQS</h2> <p>先看一些概念：</p> <p><strong>独占锁</strong>：同一时刻，只能有一个线程获得同步状态（锁）。而其他线程进入同步队列等待。</p> <p><strong>共享锁</strong>：同一时刻，可以有多个线程获得同步状态。如读写锁。</p> <p><strong>可重入锁</strong>：同一个线程对同一个共享资源的重复加锁。</p> <p><strong>同步队列</strong>：所有获取锁失败的线程，进入同步队列等待再次获取锁。</p> <p><strong>等待队列</strong>：已经拿到锁的线程，等待其他资源时，主动释放锁，进入等待队列，等待被唤醒后，重新进入同步队列，尝试获取锁。</p> <p><strong>公平锁</strong>：对一个资源首次获取锁时，在绝对时间上，先对锁进行获取的请求一定先被满足。也就是，等待时间最长的线程最优先获取锁。</p> <p><strong>非公平锁</strong>：对一个资源首次获取锁时，不考虑等待队列中线程请求锁的顺序，只要有一个节点 CAS 设置同步状态成功，表示获得锁。</p> <h3 id="_1-1-lock-接口"><a href="#_1-1-lock-接口" class="header-anchor">#</a> 1.1 Lock 接口</h3> <h4 id="_1-1-1-lock-与-synchronized"><a href="#_1-1-1-lock-与-synchronized" class="header-anchor">#</a> 1.1.1 Lock 与 Synchronized</h4> <p>在 Java 5 之后，并发保重新增 Lock 接口用来实现锁功能，它提供了与 Synchronized 类似的功能。</p> <table><thead><tr><th>Synchronized 关键字</th> <th>Lock 接口</th></tr></thead> <tbody><tr><td>不可操作：隐式获取和释放锁</td> <td>可操作：显示获取和释放锁</td></tr> <tr><td>阻塞获取锁</td> <td>尝试非阻塞的获取锁</td></tr> <tr><td>不可中断（等待获取锁的过程中）</td> <td>可中断</td></tr> <tr><td>无</td> <td>可超时</td></tr> <tr><td>仅非公平</td> <td>公平锁</td></tr> <tr><td>可重入</td> <td>可重入</td></tr></tbody></table> <h4 id="_1-1-2-lock-接口定义的方法"><a href="#_1-1-2-lock-接口定义的方法" class="header-anchor">#</a> 1.1.2 Lock 接口定义的方法</h4> <p>Lock 接口中仅定义了六个方法：</p> <table><thead><tr><th>方法名称</th> <th>描述</th></tr></thead> <tbody><tr><td><code>void lock();</code></td> <td>获取锁。当前线程获得锁后，该方法返回。</td></tr> <tr><td><code>void lockInterruptibly() throws InterruptedException;</code></td> <td>可响应中断的获取锁。在锁的获取中，可以中断当前线程。</td></tr> <tr><td><code>boolean tryLock();</code></td> <td>尝试非阻塞的获取锁。<br>该方法立即返回，获取成功返回 <code>true</code>，获取失败返回 <code>fasle</code>。</td></tr> <tr><td><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code></td> <td>超时、可响应中断的获取锁。当前线程在以下 种情况下会返回：<br>1. 当前线程在超时时间内获得了锁，返回 <code>true</code>；<br>2. 当前线程在超时时间内被中断，抛出中断异常；<br>3. 超时时间结束，返回 <code>false</code>。</td></tr> <tr><td><code>void unlock();</code></td> <td>释放锁。</td></tr> <tr><td><code>Condition newCondition();</code></td> <td>获取监视器组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 <code>wait()</code> 方法，调用后，当前线程释放锁。</td></tr></tbody></table> <h4 id="_1-1-3-lock-的使用"><a href="#_1-1-3-lock-的使用" class="header-anchor">#</a> 1.1.3 Lock 的使用</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment">// TODO</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>加锁不要写在 try 块中</strong>，因为加锁时发生异常，会导致锁无故释放。</li> <li><strong>解锁在 finally 块中进行</strong>，目的是保证在获取到锁后，最终一定能被释放。</li></ul> <p>最后：Lock 接口的实现类基本都是通过聚合了一个同步器的子类来完成线程访问控制。</p> <h3 id="_1-2-队列同步器-abstractqueuedsynchronizer-aqs"><a href="#_1-2-队列同步器-abstractqueuedsynchronizer-aqs" class="header-anchor">#</a> 1.2  队列同步器（AbstractQueuedSynchronizer，AQS）</h3> <h4 id="_1-2-1-使用方式-继承"><a href="#_1-2-1-使用方式-继承" class="header-anchor">#</a> 1.2.1 使用方式 —— 继承</h4> <ul><li>子类通过继承同步器并实现它的抽象方法来管理同步状态。</li> <li>子类一般定义为静态内部类。（自定义同步组件类的内部类，如 <code>ReentrantLock</code> 类的内部类 <code>Sync</code> 类）</li></ul> <h4 id="_1-2-2-内容"><a href="#_1-2-2-内容" class="header-anchor">#</a> 1.2.2 内容</h4> <p>提供若干同步队列管理方法、同步状态获取与释放的方法以及 <code>ConditionObject</code> 对象，供自定义同步组件使用。</p> <p><img src="/vssue-comment/assets/img/aqs1.b6258a8c.png" alt=""></p> <p><img src="/vssue-comment/assets/img/aqs2.cb2a076d.png" alt=""></p> <h4 id="_1-2-3-同步状态的访问与修改-state-变量"><a href="#_1-2-3-同步状态的访问与修改-state-变量" class="header-anchor">#</a> 1.2.3 同步状态的访问与修改 —— state 变量</h4> <p><strong>整型变量 state</strong> 及其对应的三个方法：</p> <ul><li><code>int getState()</code>：获取当前同步状态</li> <li><code>void setState(int newState)</code>：设置当前同步状态</li> <li><code>boolean compareAndSetState(int expect, int update)</code>：使用 CAS 设置当前状态，保证状态设置的原子性。</li></ul> <p>不同的同步器（锁），state 表示的同步状态有所不同：</p> <ul><li>独占不可重入锁：只有两个值 0 和 1。0：表示未加锁；1：表示已加锁。</li> <li>独占可重入锁：大于 0 的值。0：表示未加锁，n：表示加锁重入的次数。</li> <li>共享锁：将 <code>int</code> 型变量拆分为两个 <code>unsigned short</code>，以此来分别表示读锁和写锁的状态。详看读写锁。</li></ul> <h4 id="_1-2-4-设计原则-模版方法模式"><a href="#_1-2-4-设计原则-模版方法模式" class="header-anchor">#</a> 1.2.4 设计原则 —— 模版方法模式</h4> <p>同步器是基于<strong>模版方法模式</strong>实现的。使用者需要继承同步器并重写指定的方法，然后将它组合在自定义同步组件的具体实现中，最后调用同步器提供的模版方法，而这些模版方法会调用使用重写的方法。</p> <h5 id="_1-2-4-1-需要重写的方法-需要自己实现同步状态如何获取与释放"><a href="#_1-2-4-1-需要重写的方法-需要自己实现同步状态如何获取与释放" class="header-anchor">#</a> 1.2.4.1 需要重写的方法 —— 需要自己实现同步状态如何获取与释放</h5> <ul><li><p>Exclusive Mode Method</p> <ul><li><p>独占式的获取同步状态：需要使用 CAS 设置同步状态。</p> <p><code>protected boolean tryAcquire(int arg) {throw new UnsupportedOperationException();}</code></p></li> <li><p>独占式的释放同步状态：</p> <p><code>protected boolean tryRelease(int arg) {throw new UnsupportedOperationException();}</code></p></li> <li><p>判断当前同步器是否在独占模式下被线程占用，如果是返回 <code>true</code>，否则返回 <code>false</code>：
<code>protected boolean isHeldExclusively() {throw new UnsupportedOperationException();}</code></p></li></ul></li> <li><p>Shared Mode Method</p> <ul><li><p>共享式的获取同步状态：返回大于等于 0 的值，标示获取成功，反之，获取失败。</p> <p><code>protected int tryAcquireShared(int arg) {throw new UnsupportedOperationException();}</code></p></li> <li><p>共享式的释放同步状态：</p> <p><code>protected boolean tryReleaseShared(int arg) {throw new UnsupportedOperationException();}</code></p></li></ul></li></ul> <h5 id="_1-2-4-2-部分模版方法-同步器提供的模版方法帮助获取同步状态及管理同步队列"><a href="#_1-2-4-2-部分模版方法-同步器提供的模版方法帮助获取同步状态及管理同步队列" class="header-anchor">#</a> 1.2.4.2 部分模版方法 —— 同步器提供的模版方法帮助获取同步状态及管理同步队列</h5> <ul><li><p>Exclusive Mode Method</p> <ul><li><p>独占式获取同步状态，如果获取成功则返回，否则该线程进入同步队列等待。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>独占式、可中断获取同步状态，如果获取成功则返回，否则该线程进入同步队列等待。如果当前线程被中断抛出异常并返回。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>独占式、可超时中断获取同步状态，如果当前线程在超时时间内没有获取到同步状态，返回 <code>false</code>，如果获取到了返回 <code>true</code>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>独占式释放同步状态，并唤醒后继节点。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>Shared Mode Method</p> <ul><li><p>共享式获取同步状态，如果获取成功则返回，否则该线程进入同步队列等待。与独占式的区别是<strong>同一时刻可以有多个线程获得同步状态</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>共享式、可中断获取同步状态，同上。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>共享式、可超时中断获取同步状态，同上。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquireSharedNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
    <span class="token function">doAcquireSharedNanos</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>共享式的释放同步状态，同上。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>获取等待在同步队列上的线程集合</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> p <span class="token operator">=</span> tail<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> p<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_1-3-同步队列"><a href="#_1-3-同步队列" class="header-anchor">#</a> 1.3 同步队列</h3> <p>同步器（AQS）依赖内部的同步队列（一个 FIFO 的双向队列）来完成同步状态的管理。</p> <h4 id="_1-3-1-同步队列的结构"><a href="#_1-3-1-同步队列的结构" class="header-anchor">#</a> 1.3.1 同步队列的结构</h4> <ul><li><p>每个 Lock 对象都包含一个队列（同步队列），该队列是实现加锁/解锁的关键。</p></li> <li><p>同步队列是一个 FIFO 队列，该队列的每个节点都包含一个线程的引用、等待状态、前驱后继节点指向以及节点类型。该线程就是获取同步状态失败的线程。</p></li> <li><p>一个同步器对象包含一个等待队列，同步器对象包含首节点（head）和尾节点（tail）。</p></li></ul> <p><img src="/vssue-comment/assets/img/sync_queue.33adadb0.png" alt=""></p> <h4 id="_1-3-2-同步队列节点的入列和出列"><a href="#_1-3-2-同步队列节点的入列和出列" class="header-anchor">#</a> 1.3.2 同步队列节点的入列和出列</h4> <ul><li>入列：如果一个线程获取同步状态失败，那么同步器就将当前线程以及等待状态信息构造成一个节点（Node）并加入同步队列尾部，进入阻塞状态。</li> <li>出列：首节点的线程在释放同步状态时，将唤醒后继节点，而后继节点将会在获取同步状态成功将自己设置为首节点。</li></ul> <h4 id="_1-3-3-节点-abstractqueuedsynchronizer-node"><a href="#_1-3-3-节点-abstractqueuedsynchronizer-node" class="header-anchor">#</a> 1.3.3 节点（AbstractQueuedSynchronizer.Node）</h4> <p>队列（同步队列、等待队列）中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态、前驱后继节点以及节点类型（独占式还是共享式），如下表：</p> <table><thead><tr><th>属性</th> <th>描述</th></tr></thead> <tbody><tr><td><code>volatile int waitStatus;</code></td> <td>线程的等待状态。包含以下值：<br>1. CANCELLED，值为 1。<strong>取消</strong>，<br>    表示在同步队列中自旋的节点由于线程超时或中断，<br>    取消等待，移出同步队列。<br>2. SIGNAL，值为 -1。<strong>发信号</strong>，<br>    表示通知后继节点，使后继节点中的线程得以运行。<br>3. CONDITION，值为 -2。<strong>等待队列专用</strong>，<br>    表示在等待队列中的节点，<br>    等到 signal() 方法调用后移动到同步队列尾部。<br>4. PROPAGATE，值为 -3。<strong>传播</strong>，<br>    下一次共享式同步状态获取将会无条件的被传播下去，<br>    使连续的读操作节点依次进入临界区。<br>5. INITIAL，值为 0。默认，<strong>初始状态</strong>，<br>    新节点会处于这种状态。</td></tr> <tr><td><code>Node nextWaiter;</code></td> <td>等待队列中的后继节点。</td></tr> <tr><td><code>volatile Node prev;</code></td> <td>节点的前驱节点，<br>当节点被取消时（线程被中断）让当前节点的前驱节点，<br>直接指向当前节点的后继节点。<br>当节点被加入到队列尾部时被设置。</td></tr> <tr><td><code>volatile Node next;</code></td> <td>后继节点，用于维护队列顺序。</td></tr> <tr><td><code>volatile Thread thread;</code></td> <td>获取同步状态的线程。</td></tr></tbody></table> <blockquote><p>多个线程获取同步状态时，由于只能有一个线程能够成功获取同步状态，因此设置头节点的方法不需要使用 CAS 保证。其他没有获取到同步状态的线程被构造成节点并加入到同步队列尾部，此时必须使用 CAS 保证线程安全的设置尾节点。</p></blockquote> <h3 id="_1-4-同步器的独占模式"><a href="#_1-4-同步器的独占模式" class="header-anchor">#</a> 1.4 同步器的独占模式</h3> <p>独占式 <code>Node.EXCLUSIVE</code>，同一时刻只能有一个线程成功获取同步状态。</p> <h4 id="_1-4-1-同步器如何独占式管理线程-获取与释放"><a href="#_1-4-1-同步器如何独占式管理线程-获取与释放" class="header-anchor">#</a> 1.4.1 同步器如何独占式管理线程（获取与释放）</h4> <p>同步器以独占式管理同步队列，使线程竞争同步状态流程：</p> <p><img src="/vssue-comment/assets/img/acquire.18be0a10.png" alt=""></p> <p>同步器的 <code>acquire(int arg)</code> 模版方法：（该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。）</p> <ul><li>先调用在自定义同步组件（比如 <code>ReentrantLock</code> ）中重写的 <code>tryAcquire(int acquires)</code> 方法尝试获取同步状态。</li> <li>如果获取失败调用 <code>addWaiter(Node.EXCLUSIVE)</code> 方法将失败的线程构造成节点并加入到同步队列。</li> <li>然后在调用 <code>acquireQueued(final Node node, int arg)</code> 方法进入自旋获取同步状态，如果当前节点的前驱节点为头节点，尝试再次获取同步状态。</li></ul> <p>同步器的 <code>release(int arg)</code> 模版方法：</p> <ul><li>先调用在自定义同步组件（比如 <code>ReentrantLock</code> ）中重写的 <code>tryRelease(int arg)</code> 尝试释放同步状态。</li> <li>释放成功之后唤醒后继节点，<code>unparkSuccessor(Node node)</code> 方法使用 <code>LockSupport</code> 来唤醒处于等待状态的线程。</li></ul> <h4 id="_1-4-2-同步器对独占锁加锁模版的规则"><a href="#_1-4-2-同步器对独占锁加锁模版的规则" class="header-anchor">#</a> 1.4.2 同步器对独占锁加锁模版的规则</h4> <p>获取独占锁（写锁）时同步器对竞争独占锁的线程所做的操作有：</p> <ul><li>入队：获取同步状态失败的线程，打包成节点，加入同步队列尾部，成为 <code>tail</code> 节点；</li> <li>执行：判断当前节点的前驱节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行；</li> <li>等待：未获取到锁或者前驱节点不是头节点，就代表该节点需要继续自旋等待。</li></ul> <h4 id="_1-4-3-注意事项"><a href="#_1-4-3-注意事项" class="header-anchor">#</a> 1.4.3 注意事项</h4> <p>在获取同步状态时，同步器维护一个同步队列，获取同步状态失败的线程会被爱加入到队列尾部并在队列中自旋；移出队列（停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 <code>tryRelease(int arg)</code> 方法释放同步状态，然后唤醒头节点的后继节点。</p> <p>⚠️对于独占式：</p> <ul><li>在获取同步状态时，
<ul><li>如果同步状态是第一次被获取（即 <code>getState() == 0</code>）此时未被某个线程占有，多个线程来竞争同步状态时需要循环 CAS 来保证线程安全（即，在重写 <code>tryAcquire(int acquires)</code> 方法时，需要使用 <code>compareAndSetState(int expect, int update)</code> 方法来设置同步状态）。</li> <li>如果同步状态已经被某个线程所占用，且当前线程就是独占线程时，那么在重写 <code>tryAcquire(int acquires)</code> 方法时，直接调用 <code>setState(int newState)</code> 方法来设置同步状态。</li></ul></li> <li>在释放同步状态时，
<ul><li>重写 <code>tryRelease(int releases)</code> 方法时，直接调用 <code>setState(int newState)</code> 方法来设置同步状态（因为它是独占的，当前线程获取了同步状态，还是只能由当前线程释放同步状态）。</li></ul></li></ul> <h3 id="_1-5-同步器的共享模式"><a href="#_1-5-同步器的共享模式" class="header-anchor">#</a> 1.5 同步器的共享模式</h3> <p>共享式 <code>Node.SHARED</code>，同一时刻可能会有多个线程成功获取同步状态。</p> <p>以文件读写为例，如果一个程序对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够多个线程同时进行。写操作要求对资源独占式访问，而读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源访问情况如下图：</p> <p><img src="/vssue-comment/assets/img/exclusive_share.524d90b3.png" alt=""></p> <h4 id="_1-5-1-同步器如何共享式管理线程-获取与释放"><a href="#_1-5-1-同步器如何共享式管理线程-获取与释放" class="header-anchor">#</a> 1.5.1 同步器如何共享式管理线程（获取与释放）</h4> <p>同步器的 <code>acquireShared(int arg)</code> 模版方法：</p> <ul><li>先调用在自定义同步组件（比如 <code>ReentrantReadWriteLock</code> ）中重写的 <code>tryAcquireShared(int arg)</code> 方法尝试获取同步状态，当返回值大于等于 0 时，表示能过获取到同步状态。</li> <li>如果获取失败调用 <code>doAcquireShared(int arg)</code> 方法，将失败的线程构造成节点并加入到同步队列（也是同样的方法 <code>addWaiter(Node.SHARED)</code>），并进入自旋获取同步状态，如果当前节点的前驱节点为头节点，尝试再次获取同步状态。</li></ul> <p>同步器的 <code>releaseShared(int arg)</code> 模版方法：</p> <ul><li>先调用在自定义同步组件（比如 <code>ReentrantReadWriteLock</code> ）中重写的 <code>tryReleaseShared(int arg)</code> 方法尝试释放同步状态。</li> <li>释放成功之后调用 <code>doReleaseShared()</code> 方法唤醒后继节点。</li></ul> <h4 id="_1-5-2-同步器对共享锁加锁模版的规则"><a href="#_1-5-2-同步器对共享锁加锁模版的规则" class="header-anchor">#</a> 1.5.2 同步器对共享锁加锁模版的规则</h4> <p>获取共享锁（读锁）时同步器对竞争共享锁的线程所做的操作有：</p> <ul><li>入队：获取同步状态失败的线程，打包成节点，加入同步队列尾部，成为 <code>tail</code> 节点；</li> <li>执行：判断当前节点的前驱节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行；</li> <li>传播：如果后面的节点还是共享锁（读锁），继续尝试获取锁，一直传播下去，直到遇到获取独占锁的节点。这也就是共享锁（读锁）的传播；</li> <li>等待：未获取到锁或者前驱节点不是头节点，就代表该节点需要继续自旋等待。</li></ul> <p>与独占锁（写锁）比较一下，共享锁（读锁）多了一个传播的逻辑，来看一下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// ◉ 循环判断当前节点的前驱节点是否为头节点，如果是，则获取锁。</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// ◉ 获取到共享锁之后将当前节点设置为头节点。（此处既是传播）</span>
          <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
          p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>
        interrupted <span class="token operator">|=</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>
      <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// ◉ 将当前的节点设置为头节点，判断如果是共享锁，确保释放同步状态的传播。</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// Record old head for check below</span>
  <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
      <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// ◉ 确保释放同步状态的传播，如果需要 signal 则唤醒当前节点的后继节点。</span>
<span class="token comment">// 如果不需要，将状态设置为传播，确保在释放同步状态的时候，继续传播</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// loop to recheck cases</span>
        <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒当前节点</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
               <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// loop on failed CAS</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token comment">// loop if head changed</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_1-5-3-注意事项"><a href="#_1-5-3-注意事项" class="header-anchor">#</a> 1.5.3 注意事项</h4> <p>⚠️对于共享式来说，它能够支持多个线程同时访问并发组件（比如 Semaphore），所以当它获取与释放同步状态时，需要循环 CAS 来保证线程安全（即，在重写 <code>tryAcquireShared(int arg)</code> 和 <code>tryReleaseShared(int arg)</code> 方法时，需要使用 <code>compareAndSetState(int expect, int update)</code> 方法来设置同步状态）。</p> <h3 id="_1-6-同步器的独占式超时模式"><a href="#_1-6-同步器的独占式超时模式" class="header-anchor">#</a> 1.6 同步器的独占式超时模式</h3> <p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”。</p> <h4 id="_1-6-1-同步器如何独占式超时管理线程"><a href="#_1-6-1-同步器如何独占式超时管理线程" class="header-anchor">#</a> 1.6.1 同步器如何独占式超时管理线程</h4> <p>同步器以独占式、可超时、可中断管理同步队列，使线程竞争同步状态流程：</p> <p><img src="/vssue-comment/assets/img/acquire_timeout.444e0f09.png" alt=""></p> <h2 id="_2-独占锁-不可重入-mutex"><a href="#_2-独占锁-不可重入-mutex" class="header-anchor">#</a> 2. 独占锁（不可重入） —— Mutex</h2> <p>同一时刻，只允许一个线程（独占）占有锁一次（不可重入）。</p> <p>直接看 <code>Mutex</code> 代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>

    <span class="token comment">// 自定义一个同步器，它继承了同步器（AQS）并定义为静态内部类</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当状态为 0 时获取锁，并设置独占线程</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 此处体现不可重入！！！</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 释放锁，将状态设置为 0，并取消独占线程</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 是否处于独占状态</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 返回一个 Condition，每个 Condition 都包含一个 Condition 队列</span>
        <span class="token keyword">final</span> <span class="token class-name">ConditionObject</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将操作代理到 Sync 上</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 查询是否有线程在等待获取同步状态。</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>测试不可重入：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MutexTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一次加锁</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">&quot;已加锁！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第二次加锁，将被阻塞，不再往下执行</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">&quot;已解锁！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Worker</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        worker<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>Thread-3已加锁！
</code></pre></div><p>线程调用 <code>Mutex</code> 的 <code>lock()</code> 方法加锁后，再次调用 <code>lock()</code> 方法，则该线程被自己阻塞，不再往下执行。</p> <h2 id="_3-独占锁-可重入-reentrantlock"><a href="#_3-独占锁-可重入-reentrantlock" class="header-anchor">#</a> 3. 独占锁（可重入） —— ReentrantLock</h2> <p>同一时刻，允许一个线程（独占）占有锁多次（可重入）。</p> <p>ReentrantLock 提供构造函数，来控制锁是否公平。默认为非公平锁。因为非公平虽然会较大概率的造成线程“饥饿”， 但是极少的线程切换带来了更高的效率，更大的吞吐量。</p> <h3 id="_3-1-实现可重入"><a href="#_3-1-实现可重入" class="header-anchor">#</a> 3.1 实现可重入</h3> <p>重进入指<strong>线程在获取到锁之后能够再次获取该锁而不发生阻塞</strong>。需解决两个问题：</p> <ul><li><p>识别线程是否为当前占据锁的线程，如果是才能再次获取。</p> <blockquote><p>AOS（AbstractOwnableSynchronizer），它是 AQS 的父类，这个类为创建具有所有权概念的锁和同步器提供了基础。基于它可以实现锁是否为某个线程独占。</p> <p>AOS 类仅包含一个 <code>Thread</code> 类型成员变量（私有且 <code>transient</code> 关键字修饰）及其 <code>get()、set()</code> 方法。</p> <p>使用：</p> <ol><li>当一个线程获取到同步状态后，调用 <code>setExclusiveOwnerThread(current)</code> 设置独占线程。</li> <li>当线程再次获取同步状态时，使用 <code>Thread.currentThread() == getExclusiveOwnerThread()</code> 判断当前线程是否为锁持有的线程。</li></ol> <p><code>ReentrantLock</code> 的 <code>nonfairTryAcquire(int acquires)</code> 方法（非公平锁）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock cou/nt exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></li> <li><p>锁的最终释放。</p> <blockquote><p>成功获取锁的线程，当它再次获取锁，只是增加了同步状态的值（整型变量 state 的值）。</p> <p>所以，在释放同步状态时，减少同步状态的值，直到同步状态的值为 0 时，返回 <code>true</code> ，并取消线程独占，最终释放成功。</p> <p><code>ReentrantLock</code> 的 <code>tryRelease(int releases)</code> 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></li></ul> <h3 id="_3-2-公平与非公平的区别"><a href="#_3-2-公平与非公平的区别" class="header-anchor">#</a> 3.2 公平与非公平的区别</h3> <p>多个线程在首次获取锁时，公平锁倾向授予等待时间最长的线程访问权限。非公平锁不能保证任何特定的访问顺序。</p> <p><code>ReentrantLock</code> 的 <code>tryAcquire(int acquires)</code> 方法（公平锁）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法与非公平锁获取方法比较，唯一不同在于：首次获取锁时，增加 <code>hasQueuedPredecessors()</code> 判断条件。</p> <blockquote><p>hasQueuedPredecessors() 方法：</p> <ul><li><p>如果当前线程前面有排队线程返回 <code>true</code>。</p></li> <li><p>如果当前线程位于队列首部或者队列为空返回 <code>false</code>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Node</span> h<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// traverse in case of concurrent cancellation</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> p <span class="token operator">=</span> tail<span class="token punctuation">;</span> p <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
          s <span class="token operator">=</span> p<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></blockquote> <p>公平锁保证了等待时间最长的线程优先获取锁，而代价是进行大量的线程切换。</p> <p>非公平锁可能使线程“饥饿”，但极少的线程切换，保证了更大的吞吐量。</p> <h3 id="_3-3-测试可重入"><a href="#_3-3-测试可重入" class="header-anchor">#</a> 3.3 测试可重入</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLockTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> threadName <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第一次加锁</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">&quot;已加锁！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第二次加锁，不会阻塞，继续执行</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">&quot;已解锁！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Worker</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        worker<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>Thread-3已加锁！
Thread-3
Thread-3已解锁！
Thread-3已加锁！
Thread-3
Thread-3已解锁！
</code></pre></div><p>上面的不可重入锁 <code>Mutex</code> 在第二次加锁后被阻塞，不再继续往下执行。而 <code>ReentrantLock</code> 在多次加锁后继续往下执行，支持可重入。</p> <h2 id="_4-共享锁-读写锁-reentrantreadwritelock"><a href="#_4-共享锁-读写锁-reentrantreadwritelock" class="header-anchor">#</a> 4. 共享锁 —— 读写锁（ReentrantReadWriteLock）</h2> <p>上面介绍的独占锁也叫排他锁，在同一时刻只允许一个线程访问。</p> <p>读写锁在同一时刻允许多个线程访问（共享性）。具体来讲：</p> <ul><li>读锁和写锁可以看作读写锁的两种状态。</li> <li>读锁是一个线程对共享资源进行读操作时对资源加的锁。写锁是一个线程对共享资源进行写操作时对资源加的锁。</li> <li>同一个线程对同一个共享资源既可以进行读加锁（读操作时）也可以进行写加锁（写操作时）。（前面讲的排他锁是同一个线程对共享资源加锁时不分操作，直接上锁，不允许其他线程访问该共享资源。）</li> <li>读锁允许多个线程对同一共享资源同时加锁。写锁只允许一个线程对共享资源加锁，其他线程均被阻塞。</li> <li>所以，在某个线程的写操作访问共享资源的时候，其他线程的所有读写操作均被阻塞。但是该线程的读操作并未被阻塞。</li></ul> <p>（书上的原话：*读写锁在同一时刻允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。*跟我理解的不太一样，按照书上的意思，就不能实现锁降级，即把持住写锁去获得读锁再释放写锁。通过源码分析，同一线程，获取写锁后，是可以获取读锁的。）</p> <p>读写锁维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发相比一般的排他锁有很大提升。</p> <p>读写锁也支持重进入：</p> <ul><li>线程获取读锁之后能够再次获得读锁。</li> <li>线程在获取写锁之后，当前线程能够再次获取写锁，同时也可以获得读锁。</li></ul> <p>综上来说：</p> <ul><li>读锁 —— 支持重进入的共享锁：可以被多个线程同时获取，且可以获取多次。</li> <li>写锁 —— 支持重进入的排他锁：只能被一个线程获取多次。在未释放写锁前，其他线程均阻塞。</li></ul> <h3 id="_4-1-readwritelock-接口"><a href="#_4-1-readwritelock-接口" class="header-anchor">#</a> 4.1 ReadWriteLock 接口</h3> <p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口。</p> <p><code>ReadWriteLock</code> 接口仅提供 <code>Lock readLock()</code> 方法和 <code>Lock writeLock()</code> 方法。</p> <p><code>ReentrantReadWriteLock</code> 提供的部分监控内部工作状态的方法：</p> <table><thead><tr><th>方法名称</th> <th>描述</th></tr></thead> <tbody><tr><td>int getReadLockCount()</td> <td>当前读锁被获取的次数（获得读锁的多个线程所有重入次数的和）。</td></tr> <tr><td>int getReadHoldCount()</td> <td>当前线程获取读锁的次数（重入的次数）。</td></tr> <tr><td>boolean isWriteLocked()</td> <td>判断写锁是否被获取。</td></tr> <tr><td>int getWriteHoldCount()</td> <td>当前线程获取写锁的次数（重入的次数）。</td></tr></tbody></table> <h3 id="_4-2-读写锁状态设计"><a href="#_4-2-读写锁状态设计" class="header-anchor">#</a> 4.2 读写锁状态设计</h3> <p>AQS 使用一个整型变量 <code>state</code> 来管理同步状态。读写锁同样依赖这个整型变量 state。</p> <p>在独占锁中，整型变量 <code>state</code> 的值表示被一个线程重入（重复获取同步状态）的次数。</p> <p>读写锁需要在一个整型变量 <code>state</code> 上维护多个读线程与一个写线程的同步状态。</p> <p>来看具体设计：将这个变量 <code>state</code> <em><strong>按位切割使用</strong></em>，切分为 <code>unsigned short</code> 的两部分，高 16 位表示读状态，低 16 位表示写状态。</p> <p><img src="/vssue-comment/assets/img/read_write.f898c941.png" alt=""></p> <p>上图中的同步状态表示一个线程同时获取了写锁和读锁，且写锁获得三次，读锁获得两次。</p> <p>读写状态获取 —— 通过位运算快速确定：</p> <ul><li>写状态 = <code>getState() &amp; 0x0000FFFF</code>（将高 16 位全部抹去）</li> <li>读状态 = <code>getState() &gt;&gt;&gt; 16</code>（无符号补 0 右移 16 位）</li></ul> <p>读写状态更新：</p> <ul><li>写状态增加 1 时：<code>getState() + 1</code></li> <li>读状态增加 1 时：<code>getState() + (1&lt;&lt;16)</code>，也就是 <code>getState() + 0x00010000</code></li></ul> <table><thead><tr><th>16 进制</th> <th>10 进制</th> <th>2 进制</th> <th>移位运算</th></tr></thead> <tbody><tr><td>0x0000FFFF</td> <td>65535</td> <td>1111111111111111</td> <td>(1&lt;&lt;16) -1</td></tr> <tr><td>0x00010000</td> <td>65536</td> <td>10000000000000000</td> <td>1&lt;&lt;16</td></tr></tbody></table> <p>推论：<strong>getState() 不等于 0 时，当写状态等于 0 时，则读状态大于 0，即读锁已被获取。</strong></p> <h3 id="_4-3-写锁的获取与释放"><a href="#_4-3-写锁的获取与释放" class="header-anchor">#</a> 4.3 写锁的获取与释放</h3> <p>写锁是一个支持重进入的排他锁。只能被一个线程获取多次。在未释放写锁前，其他线程均阻塞。</p> <p>写状态是当前线程写锁重入的次数。</p> <h4 id="_4-3-1-reentrantreadwritelock-对写锁获取的实现"><a href="#_4-3-1-reentrantreadwritelock-对写锁获取的实现" class="header-anchor">#</a> 4.3.1 ReentrantReadWriteLock 对写锁获取的实现</h4> <p>获取写锁的条件：</p> <ul><li>读锁已经获取且写锁未获取时，不管当前线程是否为获取读锁的线程，都无法获取写锁。因为，<strong>读写锁要确保写锁的操作对读锁可见。</strong></li> <li>写锁已经获取，且当前线程为获取写锁的线程时，则再次获得写锁。若当前线程不是获取写锁的线程，则阻塞。</li> <li>读锁和写锁都未获取时，有可能获取写锁。（考虑公平与非公平，且以 CAS 设置）</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取写锁。w == 0 表示写锁未被获取。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>
    <span class="token comment">// ◉ 如果读锁获取，而写锁未获取，返回 false。</span>
    <span class="token comment">// ◉ 如果写锁已经获取（此时不用关心读锁），且当前线程不是获取写锁的线程，返回 false。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// ◉ 写锁已经获取且当前线程为获取写锁的线程，如果写锁大于最大加速次数时，抛出 Error。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_COUNT<span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Reentrant acquire</span>
    <span class="token comment">// ◉ 写锁已经获取且当前线程为获取写锁的线程，且写锁小于最大加锁次数时，再次获取写锁，返回 true。</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ◉ 读锁和写锁从未被获取时，以 CAS 获取写锁，获取成功，则设置独占线程并返回 true。</span>
  <span class="token comment">// ◉ 获取失败，则返回 false。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>writerShouldBlock()</code> 方法，</p> <ul><li>在非公平锁情况下，总是返回 false；</li> <li>在公平锁情况下：</li> <li>如果当前线程在同步队列首部或者队列为空，返回 false。</li> <li>如果当前线程前面有排队的线程，返回 true（即，当前线程应该被阻塞）。</li></ul></blockquote> <h4 id="_4-3-2-reentrantreadwritelock-对写锁释放的实现"><a href="#_4-3-2-reentrantreadwritelock-对写锁释放的实现" class="header-anchor">#</a> 4.3.2 ReentrantReadWriteLock 对写锁释放的实现</h4> <p>释放写锁与独占锁的释放过程基本类似，每次释放均减少写状态，减少的值是 1，当写状态为 0 时表示写锁已经被释放。</p> <h3 id="_4-4-读锁的获取与释放"><a href="#_4-4-读锁的获取与释放" class="header-anchor">#</a> 4.4 读锁的获取与释放</h3> <p>读锁是一个支持重进入的共享锁。能够被多个线程同时获取，且可以获取多次。</p> <p><strong>读状态是所有线程获取读锁次数的总和</strong>。因此每个线程各自获取读锁的次数只能保存在 ThreadLocal 中。</p> <h4 id="_4-4-1-reentrantreadwritelock-对读锁获取的实现"><a href="#_4-4-1-reentrantreadwritelock-对读锁获取的实现" class="header-anchor">#</a> 4.4.1 ReentrantReadWriteLock 对读锁获取的实现</h4> <p>获取读锁的条件：</p> <ul><li>写锁已经获取，且当前线程不是获取写锁的线程，则无法获取读锁。</li> <li>写锁已经获取，且当前线程为获取写锁的线程时，则有可能获取读锁。（考虑公平与非公平，且以 CAS 设置）</li> <li>读锁和写锁都未获取时，有可能获取读锁。（考虑公平与非公平，且以 CAS 设置）</li></ul> <p>（由于各自线程需要维护自身获取读锁的次数，此处代码比较复杂，但是原理不变。）</p> <h4 id="_4-4-2-reentrantreadwritelock-对读锁释放的实现"><a href="#_4-4-2-reentrantreadwritelock-对读锁释放的实现" class="header-anchor">#</a> 4.4.2 ReentrantReadWriteLock 对读锁释放的实现</h4> <p>释放读锁时均减少读状态（需保证线程安全，可能有多个读线程同时释放读锁），减少的值是 <code>1 &lt;&lt; 16</code>。</p> <h3 id="_4-5-锁降级"><a href="#_4-5-锁降级" class="header-anchor">#</a> 4.5 锁降级</h3> <p>所有读写锁的实现必须确保写操作对读操作的内存影响。</p> <p>读写锁支持锁降级，指把持住当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程。即写锁能够降级为读锁。</p> <p>目的：为了保证数据的可见性，如果当前线程不获取读锁直接释放写锁，假设此刻另一个线程（记作线程 T）获取写锁并修改了数据，那么当前线程无法感知到线程 T 的数据更新。如果当前线程获取读锁，则线程 T 将会被阻塞，直到当前线程释放读锁之后，线程 T 才能获取写锁更新数据。</p> <h2 id="_5-locksupport-工具"><a href="#_5-locksupport-工具" class="header-anchor">#</a> 5. LockSupport 工具</h2> <p>定义了一组公共的静态方法，提供了最基本的线程阻塞和唤醒功能。</p> <table><thead><tr><th>方法名称</th> <th>描述</th> <th>blocker 参数可选</th></tr></thead> <tbody><tr><td><code>void park(Object blocker)</code></td> <td>阻塞当前线程。以下情况唤醒线程：<br>1. 其他线程以当前线程为目标调用 <code>unpark(Thread thread)</code> 方法。<br>2. 其他线程中断当前线程。<br></td> <td>可选。阻塞对象，用来问题排查和系统监控。</td></tr> <tr><td><code>void parkNanos(Object blocker, long nanos)</code></td> <td>阻塞当前线程，最长不超过 <em>nanos</em> 纳秒。以下情况唤醒线程：<br>1. 其他线程以当前线程为目标调用 <code>unpark(Thread thread)</code> 方法。<br>2. 其他线程中断当前线程。<br>3. 超时时间到。</td> <td>可选。同上</td></tr> <tr><td><code>void parkUntil(Object blocker, long deadline)</code></td> <td>阻塞当前线程，直到 <em>deadline</em> 时间<br>（从 1970 年开始的毫秒数）以下情况唤醒线程：<br>1. 其他线程以当前线程为目标调用 <code>unpark(Thread thread)</code> 方法。<br>2. 其他线程中断当前线程。<br>3. 到达最后时间。</td> <td>可选。同上</td></tr> <tr><td><code>void unpark(Thread thread)</code></td> <td>唤醒处于阻塞状态的目标线程 thread</td> <td>N/A</td></tr> <tr><td><code>Object getBlocker(Thread t)</code></td> <td>返回阻塞对象。</td> <td>N/A</td></tr></tbody></table> <h2 id="_6-condition-接口"><a href="#_6-condition-接口" class="header-anchor">#</a> 6. Condition 接口</h2> <p>为 Lock 提供的监视器方法，以实现等待/通知模式。</p> <p>ConditionObject 是同步器 AQS 的内部类，因为它的操作需要获取相关的锁。</p> <h3 id="_6-1-常用方法"><a href="#_6-1-常用方法" class="header-anchor">#</a> 6.1 常用方法</h3> <table><thead><tr><th>方法名称</th> <th>描述</th></tr></thead> <tbody><tr><td><code>void await() throws InterruptedException</code></td> <td>当前线程释放锁并进入等待状态，直到被通知（<em>signal</em>）或中断。该方法返回的情况（即当前线程重新进入运行状态）：<br>1. 其他线程调用该 <code>Condition</code> 的 <code>signal()</code> 或 <code>signalAll()</code> 方法；<br>2. 其他线程调用 <code>interrupt()</code> 方法中断当前线程。<br>如果当前等待线程从该方法返回，则表明该线程已经获取了 <code>Condition</code> 对象对应的锁。</td></tr> <tr><td><code>void awaitUninterruptibly()</code></td> <td>同上。该方法不响应中断。</td></tr> <tr><td><code>long awaitNanos(long nanosTimeout) throws InterruptedException</code></td> <td>同上。该方法响应超时。<br>如果提前被唤醒，返回值表示剩余时间。<br>如果超时，返回 0 或者负数。</td></tr> <tr><td><code>boolean awaitUntil(Date deadline) throws InterruptedException</code></td> <td>同上。该方法响应 <em>deadline</em>。<br>如果提前被唤醒，返回 <code>true</code>。<br>否则，返回 <code>false</code>。</td></tr> <tr><td><code>boolean await(long time, TimeUnit unit) throws InterruptedException</code></td> <td>同上。需传入 <code>TimeUnit</code>。</td></tr> <tr><td><code>void signal()</code></td> <td>唤醒一个等待在 <code>Condition</code> 上的线程，该线程返回前必须获得了 <code>Condition</code> 对象对应的锁。</td></tr> <tr><td><code>void signalAll()</code></td> <td>唤醒所有等待在 <code>Condition</code> 上的线程，线程返回前必须获得了 <code>Condition</code> 对象对应的锁。</td></tr></tbody></table> <h3 id="_6-2-使用方式"><a href="#_6-2-使用方式" class="header-anchor">#</a> 6.2 使用方式</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionUseCase</span> <span class="token punctuation">{</span>
    <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionSignal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_6-3-等待队列"><a href="#_6-3-等待队列" class="header-anchor">#</a> 6.3 等待队列</h3> <p><code>Condition</code> 对象依赖内部的等待队列（一个 FIFO 的双向队列）来完成等待状态的管理。</p> <h4 id="_6-3-1-等待队列的结构"><a href="#_6-3-1-等待队列的结构" class="header-anchor">#</a> 6.3.1 等待队列的结构</h4> <ul><li>每个 <code>Condition</code> 对象都包含一个队列（等待队列），该队列是实现等待/通知功能的关键。</li> <li>等待队列是一个 FIFO 的队列，该队列的每个节点都包含了一个线程引用，该线程就是在 <code>Condition</code> 对象上等待的线程。</li> <li>一个 <code>Condition</code> 对象包含一个等待队列，<code>Condition</code> 对象拥有首节点（firstWaiter）和尾节点（lastWaiter）。</li></ul> <p><img src="/vssue-comment/assets/img/waiter_queue.0c8e9457.png" alt=""></p> <h4 id="_6-3-2-等待队列节点的入列和出列"><a href="#_6-3-2-等待队列节点的入列和出列" class="header-anchor">#</a> 6.3.2 等待队列节点的入列和出列</h4> <ul><li>入列：如果一个线程调用了 <code>Condition.await()</code> 方法，那么该线程就会释放锁，并将自己构造成节点（Node）加入等待队列尾部，进入等待状态。</li> <li>出列：调用 <code>Condition</code> 的 <code>signal()</code> 方法，会唤醒等待队列中的首节点，将其移动到同步队列尾部，并使用 <code>LockSupport</code> 唤醒节点中的线程。</li></ul> <blockquote><p>事实上，节点的定义复用了同步器中节点的定义。也就是说同步队列和等待队列中的节点类型是相同的，都是同步器的静态内部类 <code>AbstractQueuedSynchronizer.Node</code>。</p></blockquote> <p><code>Condition</code> 的 <code>signalAll()</code> 方法，相当于对等待队列中的每个节点均执行一次 <code>signal()</code> 方法。效果就是将等待队列中的所有节点都移动到同步队列中，并唤醒节点中的线程。</p> <h3 id="_6-4-synchronized-监视器与-condition-对比"><a href="#_6-4-synchronized-监视器与-condition-对比" class="header-anchor">#</a> 6.4 Synchronized 监视器与 Condition 对比</h3> <p>Synchronized 将监视器定义在 Object 对象上。同步器提供了 Condition 接口来实现自定义同步组件的监视器方法。</p> <table><thead><tr><th>对比项</th> <th>Object Monitor</th> <th>Condition</th></tr></thead> <tbody><tr><td>前置条件</td> <td>使用 synchronized 关键字加锁</td> <td>先调用 Lock.lock() 加锁，<br>然后调用 Lock.newCondition() 获取 Condition 对象</td></tr> <tr><td>调用方式</td> <td>对象直接调用<br>如：object.wait()</td> <td>使用 Condition 对象调用<br>如：condition.await()</td></tr> <tr><td>等待队列数量</td> <td>一个</td> <td>多个</td></tr> <tr><td>使当前线程释放锁并进入等待状态</td> <td>支持</td> <td>支持</td></tr> <tr><td>在等待状态中响应中断</td> <td>不支持</td> <td>支持</td></tr> <tr><td>使当前线程释放锁并进入超时等待状态</td> <td>支持</td> <td>支持</td></tr> <tr><td>使当前线程释放锁并进入等待状态直到将来某个时间</td> <td>不支持</td> <td>支持</td></tr> <tr><td>唤醒等待队列中的一个线程</td> <td>支持</td> <td>支持</td></tr> <tr><td>唤醒等待队列中的多个线程</td> <td>支持</td> <td>支持</td></tr></tbody></table> <p>在 Object 的监视器模型上（即 Synchronized 关键字），一个对象拥有一个同步队列和一个等待队列。而并发包中的同步器拥有一个同步队列和多个等待队列。如下图：</p> <p><img src="/vssue-comment/assets/img/all_queue.b1bdc687.png" alt=""></p> <p><code>Condition</code> 的实现是同步器（AQS）的内部类，因此每个 <code>Condition</code> 实例都能访问同步器提供的方法，相当于每个 <code>Condition</code> 都拥有所属同步器的引用。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-aqs" title="1. AQS">1. AQS</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-1-lock-接口" title="1.1 Lock 接口">1.1 Lock 接口</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-2-队列同步器-abstractqueuedsynchronizer-aqs" title="1.2  队列同步器（AbstractQueuedSynchronizer，AQS）">1.2  队列同步器（AbstractQueuedSynchronizer，AQS）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-3-同步队列" title="1.3 同步队列">1.3 同步队列</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-4-同步器的独占模式" title="1.4 同步器的独占模式">1.4 同步器的独占模式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-5-同步器的共享模式" title="1.5 同步器的共享模式">1.5 同步器的共享模式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-6-同步器的独占式超时模式" title="1.6 同步器的独占式超时模式">1.6 同步器的独占式超时模式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-独占锁-不可重入-mutex" title="2. 独占锁（不可重入） —— Mutex">2. 独占锁（不可重入） —— Mutex</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-独占锁-可重入-reentrantlock" title="3. 独占锁（可重入） —— ReentrantLock">3. 独占锁（可重入） —— ReentrantLock</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-实现可重入" title="3.1 实现可重入">3.1 实现可重入</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-公平与非公平的区别" title="3.2 公平与非公平的区别">3.2 公平与非公平的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-3-测试可重入" title="3.3 测试可重入">3.3 测试可重入</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_4-共享锁-读写锁-reentrantreadwritelock" title="4. 共享锁 —— 读写锁（ReentrantReadWriteLock）">4. 共享锁 —— 读写锁（ReentrantReadWriteLock）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-1-readwritelock-接口" title="4.1 ReadWriteLock 接口">4.1 ReadWriteLock 接口</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-2-读写锁状态设计" title="4.2 读写锁状态设计">4.2 读写锁状态设计</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-3-写锁的获取与释放" title="4.3 写锁的获取与释放">4.3 写锁的获取与释放</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-4-读锁的获取与释放" title="4.4 读锁的获取与释放">4.4 读锁的获取与释放</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-5-锁降级" title="4.5 锁降级">4.5 锁降级</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_5-locksupport-工具" title="5. LockSupport 工具">5. LockSupport 工具</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_6-condition-接口" title="6. Condition 接口">6. Condition 接口</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-1-常用方法" title="6.1 常用方法">6.1 常用方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-2-使用方式" title="6.2 使用方式">6.2 使用方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-3-等待队列" title="6.3 等待队列">6.3 等待队列</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-4-synchronized-监视器与-condition-对比" title="6.4 Synchronized 监视器与 Condition 对比">6.4 Synchronized 监视器与 Condition 对比</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>Privacy Policy</a></li><li class="copyright-item" data-v-3d9deeb8>MIT Licensed | Copyright © 2018-present Vue.js</li></ul></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/vssue-comment/assets/js/app.9fa4f4bb.js" defer></script><script src="/vssue-comment/assets/js/13.044f1fde.js" defer></script><script src="/vssue-comment/assets/js/3.f0de84e7.js" defer></script><script src="/vssue-comment/assets/js/9.b2c8bfda.js" defer></script>
  </body>
</html>
