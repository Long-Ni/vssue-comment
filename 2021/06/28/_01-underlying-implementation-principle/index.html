<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>volatile、synchronized 以及原子操作的实现原理及应用 | Ni&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="$page.excerpt">
    
    <link rel="preload" href="/vssue-comment/assets/css/0.styles.02c2761a.css" as="style"><link rel="preload" href="/vssue-comment/assets/js/app.9fa4f4bb.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/13.044f1fde.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/3.f0de84e7.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/12.d7671ee7.js" as="script"><link rel="prefetch" href="/vssue-comment/assets/js/10.23cc3d6b.js"><link rel="prefetch" href="/vssue-comment/assets/js/11.c63e2dcc.js"><link rel="prefetch" href="/vssue-comment/assets/js/14.399fc32e.js"><link rel="prefetch" href="/vssue-comment/assets/js/15.37bef016.js"><link rel="prefetch" href="/vssue-comment/assets/js/16.2ae3cc61.js"><link rel="prefetch" href="/vssue-comment/assets/js/17.10c0352f.js"><link rel="prefetch" href="/vssue-comment/assets/js/18.02aac107.js"><link rel="prefetch" href="/vssue-comment/assets/js/19.ac0b8b1d.js"><link rel="prefetch" href="/vssue-comment/assets/js/20.656ccc17.js"><link rel="prefetch" href="/vssue-comment/assets/js/21.d1f01d1a.js"><link rel="prefetch" href="/vssue-comment/assets/js/22.6e251d71.js"><link rel="prefetch" href="/vssue-comment/assets/js/23.caaa7b12.js"><link rel="prefetch" href="/vssue-comment/assets/js/24.33d428f1.js"><link rel="prefetch" href="/vssue-comment/assets/js/25.207f6b5f.js"><link rel="prefetch" href="/vssue-comment/assets/js/26.398d8fee.js"><link rel="prefetch" href="/vssue-comment/assets/js/27.d4ae83e5.js"><link rel="prefetch" href="/vssue-comment/assets/js/28.66c58624.js"><link rel="prefetch" href="/vssue-comment/assets/js/29.a6686645.js"><link rel="prefetch" href="/vssue-comment/assets/js/30.242e18b7.js"><link rel="prefetch" href="/vssue-comment/assets/js/31.7da4eecc.js"><link rel="prefetch" href="/vssue-comment/assets/js/32.9b8f3ea0.js"><link rel="prefetch" href="/vssue-comment/assets/js/33.075dbe36.js"><link rel="prefetch" href="/vssue-comment/assets/js/34.838ce186.js"><link rel="prefetch" href="/vssue-comment/assets/js/35.3bbd155f.js"><link rel="prefetch" href="/vssue-comment/assets/js/36.a07ab564.js"><link rel="prefetch" href="/vssue-comment/assets/js/37.50ef72a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/38.75b498ed.js"><link rel="prefetch" href="/vssue-comment/assets/js/39.3b1e3afb.js"><link rel="prefetch" href="/vssue-comment/assets/js/4.79c2a3ee.js"><link rel="prefetch" href="/vssue-comment/assets/js/40.0a6fdf1b.js"><link rel="prefetch" href="/vssue-comment/assets/js/41.9be8ec60.js"><link rel="prefetch" href="/vssue-comment/assets/js/42.9ce4d2b3.js"><link rel="prefetch" href="/vssue-comment/assets/js/43.c76f9c55.js"><link rel="prefetch" href="/vssue-comment/assets/js/44.4749cc3b.js"><link rel="prefetch" href="/vssue-comment/assets/js/45.605778e4.js"><link rel="prefetch" href="/vssue-comment/assets/js/46.fd2913a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/47.5b787534.js"><link rel="prefetch" href="/vssue-comment/assets/js/48.7cf6064e.js"><link rel="prefetch" href="/vssue-comment/assets/js/49.ffa11e3d.js"><link rel="prefetch" href="/vssue-comment/assets/js/5.6a98c4eb.js"><link rel="prefetch" href="/vssue-comment/assets/js/50.69284de8.js"><link rel="prefetch" href="/vssue-comment/assets/js/6.0cbbe057.js"><link rel="prefetch" href="/vssue-comment/assets/js/7.feaf1269.js"><link rel="prefetch" href="/vssue-comment/assets/js/8.9c40e8a4.js"><link rel="prefetch" href="/vssue-comment/assets/js/9.b2c8bfda.js"><link rel="prefetch" href="/vssue-comment/assets/js/vuejs-paginate.8412c6fc.js">
    <link rel="stylesheet" href="/vssue-comment/assets/css/0.styles.02c2761a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/vssue-comment/" class="nav-link home-link">Ni's Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/vssue-comment/" class="nav-link mobile-home-link">Ni's Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        volatile、synchronized 以及原子操作的实现原理及应用
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Ni</span> <span itemprop="address">   in 大连</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-06-28 12:00:00+0800">
      Mon Jun 28 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/vssue-comment/tag/Java" data-v-42ccfcd5><span data-v-42ccfcd5>Java</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>Java 代码在编译后成为 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终转化为汇编指令在 CPU 上执行。</p> <p>Java 的并发机制依赖于 JVM 的实现和 CPU 的指令。</p> <p>将通过以下内容来阐述 <strong>Java 并发编程的底层机制</strong>：</p> <ul><li>CAS 及原子操作的实现与应用</li> <li>volatile</li> <li>synchronized</li> <li>锁、锁状态以及锁优化</li></ul> <p>目录：</p> <div><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-cas-详解">1. CAS 详解</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-1-cas-原理">1.1 CAS 原理</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-2-cas-缺点">1.2 CAS 缺点</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-3-cas-的优点">1.3 CAS 的优点</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-4-java-对-cas-的支持">1.4 Java 对 CAS 的支持</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_1-5-自旋锁-一种锁优化策略">1.5 自旋锁（一种锁优化策略）</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_2-原子操作">2. 原子操作</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_2-1-cpu-如何实现原子操作">2.1 CPU 如何实现原子操作</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_2-2-java-如何实现原子操作">2.2 Java 如何实现原子操作</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-volatile-详解">3. volatile 详解</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-1-volatile-是什么">3.1 volatile 是什么</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-2-volatile-写-读的内存语义">3.2 volatile 写-读的内存语义</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-3-volaitle-的两个特性及实现原理">3.3 volaitle 的两个特性及实现原理</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-4-volatile-不适用的场景">3.4 volatile 不适用的场景</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_3-5-volatile-与-synchronized-的区别">3.5 volatile 与 synchronized 的区别</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_4-synchronized-详解">4. synchronized 详解</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_4-1-synchronized-的应用及其实现原理">4.1 synchronized 的应用及其实现原理</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_4-2-java-对象头">4.2 Java 对象头</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_4-3-锁升级-一种锁优化策略">4.3 锁升级（一种锁优化策略）</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_5-锁优化">5. 锁优化</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_5-1-锁粗化">5.1 锁粗化</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_5-2-锁消除">5.2 锁消除</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_5-3-自旋锁与自适应锁">5.3 自旋锁与自适应锁</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_5-4-锁升级">5.4 锁升级</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-锁">6. 锁</a><ul><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-1-锁定义">6.1 锁定义</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-2-锁的内存语义">6.2 锁的内存语义</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-3-死锁">6.3 死锁</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-4-锁的实现">6.4 锁的实现</a></li><li><a href="/vssue-comment/2021/06/28/_01-underlying-implementation-principle/#_6-5-concurrent-包的实现">6.5 Concurrent 包的实现</a></li></ul></li></ul></div> <h2 id="_1-cas-详解"><a href="#_1-cas-详解" class="header-anchor">#</a> 1. CAS 详解</h2> <p>乐观派系：他们认为事情总是会往好的方向发展，认为坏的情况发生的概率很小，只要稍加干预就足以让事情自由发展。</p> <p>悲观派系：他们认为事情如果不加以控制，以后就无法挽回，即使这种局面不会发生，也要加以控制。</p> <p>以上两种派系映射到并发编程之中就是无锁（乐观派）和加锁（悲观派）策略。因为对于加锁的并发程序来说，他们认为每次访问到共享资源的时候总会发生冲突，因此必须对每次数据操作实施加锁策略，<strong>synchronized 就是 Java 中对悲观锁的典型实现</strong>。而对于无锁的并发程序来说，他们则假设每次访问共享资源的时候没有冲突，线程可以不停的执行，无需加锁，无需等待，但是在正式更新数据之前会检查数据是否已经被其他线程改变过，如果未被其他线程改变过就将共享数据的值更新成最新值，如果共享数据的值已经被其他线程更新过，就重试，直到成功为止。<strong>CAS 机制就是乐观锁的典型实现</strong>。</p> <h3 id="_1-1-cas-原理"><a href="#_1-1-cas-原理" class="header-anchor">#</a> 1.1 CAS 原理</h3> <p>CAS，Compare and Swap：即比较并交换。其算法公式为：<code>CAS(V, E, N)</code></p> <ul><li>V：表示内存值</li> <li>E：表示预期值</li> <li>N：表示新值</li></ul> <p>当且仅当 V 等于 E 时，将 V 的值改为 N。否则不更新 V 值。</p> <h3 id="_1-2-cas-缺点"><a href="#_1-2-cas-缺点" class="header-anchor">#</a> 1.2 CAS 缺点</h3> <ul><li><p><strong>ABA 问题</strong></p> <p>假设主内存中变量的值为 A，现有两个线程（t1、t2）对其进行操作。t1 和 t2 都将 A 拷贝到自己的工作内存中，此时线程 t2 将 A 改成 B，刷新到主内存，主内存和线程 t2 的工作内存中变量的值都为 B。接下来还是线程 t2 得到执行权，t2 又将 B 更改为 A，并刷新到主内存。这时线程 t1 抢到了执行权，工作内存和主内存中变量的值都是 A，因此认为它没有被更新过，就在工作内存中将变量的值从 A 改成了 X，然后刷新到主内存。尽管线程 t1 通过 CAS 操作成功，但不代表这个过程就是没有问题的。如果一个链表的头在变化两次后恢复了原值，并不代表这个链表就没有变化。</p> <ul><li><p>解决办法：</p> <ol><li><p>版本号</p> <p>加上一个版本号之后每次操作的就是两个值：版本号和具体的值。从 A -&gt; B -&gt; A 的问题变成了 1A -&gt; 2B -&gt; 3A。</p> <p>JDK 提供了 <code>AtomicStampedReference</code> 类解决 ABA 的问题。用 <code>Pair</code> 这个内部类实现，包含两个属性，分别代表版本号和引用。在 <code>compareAndSet()</code> 中先对当前引用进行检查，再对版本号进行检查，只有全部相同时才更新值。</p></li> <li><p>通过添加一个 boolean 标记来标示要修改的值是否被更新过</p> <p>JDK 提供的 <code>AtomicMarkableReference</code> 类，就是在 <code>pari</code> 这个内部类中添加了一个 boolean 的标记，来标示被修改的值是否被更新过。</p></li> <li><p>不重复使用引用</p></li> <li><p>直接操作元素，而不是节点</p></li></ol></li></ul></li> <li><p>可能会消耗较高的 CPU</p> <p>看起来 CAS 机制比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间的等待时间。但是当有很多线程竞争的时候，会有很多次线程的 CAS 更新失败，这种情况下 CAS 机制会一直重试（自旋 CAS），造成 CPU 极大的开销。在并发量很高的情况下，如还想通过原子类来更新的话，可以使用 <code>AtomicLong</code> 的代替类 <code>AtomicAdder</code>。</p></li> <li><p>只能保证一个共享变量操作的原子性。</p> <ul><li>解决办法
<ol><li>对多个共享变量操作时，可以通过加锁的方式来保证原子性。</li> <li>可以将多个变量合并成一个变量，之后进行 CAS 操作。</li></ol></li></ul></li></ul> <h3 id="_1-3-cas-的优点"><a href="#_1-3-cas-的优点" class="header-anchor">#</a> 1.3 CAS 的优点</h3> <ul><li>并发量低的情况下，CAS 机制比锁机制效率高。</li></ul> <h3 id="_1-4-java-对-cas-的支持"><a href="#_1-4-java-对-cas-的支持" class="header-anchor">#</a> 1.4 Java 对 CAS 的支持</h3> <p>在 JDK1.5 中新添加<code>java.util.concurrent (J.U.C)</code> 中的原子类就是建立在 CAS 之上的。相比于 synchronized 的这种阻塞算法，CAS 的非阻塞算法使得 JUC 在性能上有很大的提升。</p> <h3 id="_1-5-自旋锁-一种锁优化策略"><a href="#_1-5-自旋锁-一种锁优化策略" class="header-anchor">#</a> 1.5 自旋锁（一种锁优化策略）</h3> <h4 id="_1-5-1-提出背景"><a href="#_1-5-1-提出背景" class="header-anchor">#</a> 1.5.1 提出背景</h4> <p>在多线程编程时，有时需要互斥访问，这时候就引入了锁的概念。只有获得了锁的线程，才能对资源进行访问。由于多线程的核心是 CPU 时间片的切换，所以在同一时刻只能有一个线程获得锁。那么就面临一个问题，没有获得锁的线程怎么办？</p> <p>这些未获得锁的线程通常有两种处理方式：</p> <ul><li>一种是不阻塞，线程不挂起，循环等待判断该资源是否已经释放锁，这种叫做<strong>自旋锁</strong>。</li> <li>另一种是阻塞，线程挂起，等待重新调度请求，这种叫做<strong>互斥锁</strong>。</li></ul> <h4 id="_1-5-2-自旋锁"><a href="#_1-5-2-自旋锁" class="header-anchor">#</a> 1.5.2 自旋锁</h4> <p>当一个线程尝试去获取一把锁的时候，如果这个锁已经被占用，那么此线程将会等待，间隔一段时间后再次尝试获取，循环这个过程直到获取到锁。这种机制被称为自旋锁。</p> <h4 id="_1-5-3-原理"><a href="#_1-5-3-原理" class="header-anchor">#</a> 1.5.3 原理</h4> <p>自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p> <p>因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。</p> <h4 id="_1-5-4-优缺点"><a href="#_1-5-4-优缺点" class="header-anchor">#</a> 1.5.4 优缺点</h4> <ul><li><p>优点：线程不需要切换，因此无需上下文切换，就没有用户态与内核态交换，程序性能提升。</p> <p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且对于占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，线程阻塞挂起再唤醒导致线程发生两次上下文切换！</p></li> <li><p>缺点：CPU 空转，导致 CPU 资源浪费。</p> <p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 CPU 做无用功。同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 CPU 的线程又不能获取到 CPU，造成 CPU 的浪费。所以这种情况下我们要关闭自旋锁。</p></li></ul> <h2 id="_2-原子操作"><a href="#_2-原子操作" class="header-anchor">#</a> 2. 原子操作</h2> <p>任何技术的出现都是为了解决某些特定的问题，CAS 要解决的问题就是保证原子操作。</p> <p>原子（Atomic）：不能被分割的最小粒子。</p> <p>原子操作：不可被中断的一个或者一系列操作。</p> <p>在多处理器上实现原子操作是比较复杂的问题。</p> <h3 id="_2-1-cpu-如何实现原子操作"><a href="#_2-1-cpu-如何实现原子操作" class="header-anchor">#</a> 2.1 CPU 如何实现原子操作</h3> <p>处理器使用基于对缓存加锁或总线加锁的方式来实现原子操作：</p> <ul><li>通过<strong>总线锁</strong>保证原子性：使用处理器提供的一个 Lock# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li> <li>通过<strong>缓存行锁定</strong>保证原子性：指内存区域如果被缓存在处理器的<strong>缓存行</strong>中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 Lock# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存无效。</li></ul> <h3 id="_2-2-java-如何实现原子操作"><a href="#_2-2-java-如何实现原子操作" class="header-anchor">#</a> 2.2 Java 如何实现原子操作</h3> <p>在 Java 中可以通过锁和自旋 CAS 的方式来实现原子操作：</p> <ul><li><p>使用自旋 CAS 实现原子操作：循环进行 CAS 操作直到成功为止。</p> <blockquote><p>例如：<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 等。</p></blockquote></li> <li><p>使用锁机制实现原子操作：锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。</p> <blockquote><p>JVM 内部实现很多种锁机制，有偏向锁、轻量级锁和互斥锁。</p> <p>有意思的是 JVM 实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候，使用循环 CAS 的方式来获取锁，当它退出同步块的时候使用循环 CAS 释放锁。</p></blockquote></li></ul> <h2 id="_3-volatile-详解"><a href="#_3-volatile-详解" class="header-anchor">#</a> 3. volatile 详解</h2> <p>在多线程并发编程中 synchronized 和 volatile 都扮演重要的角色。volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的可见性。volatile 比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p> <blockquote><p>CPU 通过时间片算法给可运行的线程分配运行时间，不同线程切换的时候需要将当前线程的状态保存并且恢复将要执行的线程状态信息，这个过程就叫做上下文切换。</p> <p>上下文切换非常消耗 CPU 资源，为了减少这个资源消耗，应该尽量避免上下文切换：</p> <ul><li>无锁</li> <li>CAS 机制</li> <li>使用最少线程</li> <li>使用协程</li></ul></blockquote> <h3 id="_3-1-volatile-是什么"><a href="#_3-1-volatile-是什么" class="header-anchor">#</a> 3.1 volatile 是什么</h3> <p>volatile 英文意思是不稳定的、易挥发的、变化无常的。对应到编程领域来说，如果一个变量被 volatile 修饰，意思就是告诉虚拟机这个变量是不可控的，为了使程序运行不出错，你应该做些什么来保证该变量可控、稳定。做了什么呢？在 Java 中，如果一个变量被声明成 volatile 变量，JMM 确保了所有线程看到这个变量的值是一致的。</p> <p>定义：当线程访问共享变量时，为了保证共享变量能被准确和一致的更新，线程应该确保通过排他锁（写锁）单独获得这个变量。</p> <blockquote><p>排他锁：写锁，又称独占锁。用于数据修改，确保不会同时对同一资源进行多重更新。</p> <p>共享锁：读锁，可以查看但无法修改和删除数据的一种锁机制。</p></blockquote> <h3 id="_3-2-volatile-写-读的内存语义"><a href="#_3-2-volatile-写-读的内存语义" class="header-anchor">#</a> 3.2 volatile 写-读的内存语义</h3> <p>volatile 写的内存语义：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。</p> <p>volatile 读的内存语义：当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。然后从主内存中读取个共享变量。</p> <p>总结：</p> <ul><li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读取这个 volatile 变量的某个线程发出了消息（对共享变量的修改）。</li> <li>线程 B 读一个 volatile 变量，实质上是线程 B 接受了之前某个线程发出的消息。</li> <li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li></ul> <h3 id="_3-3-volaitle-的两个特性及实现原理"><a href="#_3-3-volaitle-的两个特性及实现原理" class="header-anchor">#</a> 3.3 volaitle 的两个特性及实现原理</h3> <ul><li>可见性：对 volatile 变量所有的<strong>写操作</strong>都能立即反应到其他线程之中（通过内存屏障提供的功能 3 和 4 保障这一点）。</li> <li>禁止指令重排序（保证有序性）：通过在指令序列中<strong>插入内存屏障</strong>来禁止重排序（通过内存屏障提供的功能 1 和 2 保障这一点）。</li></ul> <p>⚠️<strong>volatile 关键字无法保证原子性。</strong></p> <p>关键字 volatile 的实现原理：观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码，会发现加入 volatile 关键字时，会多出一个 lock 前缀指令，这个 lock 前缀指令相当于一个内存屏障，而内存屏障会提供以下功能：</p> <blockquote><ol><li>它确保指令重排序时不会把内存屏障之后的指令排到前面，也不会把内存屏障之前的指令排到后面。</li> <li>执行到内存屏障指令时，<strong>确保前面的指令已经全部执行完成</strong>。</li> <li><strong>强制对缓存的修改操作立即写入主内存中</strong>。</li> <li>如果是写操作，导致其他 CPU 中的缓存无效（缓存一致性协议）。</li></ol></blockquote> <h3 id="_3-4-volatile-不适用的场景"><a href="#_3-4-volatile-不适用的场景" class="header-anchor">#</a> 3.4 volatile 不适用的场景</h3> <ul><li>运算的值依赖于变量当前的值。（不是原子操作）</li> <li>变量需要与其他状态变量沟通参与不变约束。</li></ul> <h3 id="_3-5-volatile-与-synchronized-的区别"><a href="#_3-5-volatile-与-synchronized-的区别" class="header-anchor">#</a> 3.5 volatile 与 synchronized 的区别</h3> <ol><li>本质区别：
<ul><li>volatile 告诉 JVM 当前工作内存中的变量是不确定的，需要去主内存中读取。</li> <li>synchronized 则是锁定当前变量，当线程访问某变量的时候，其他线程被阻塞。</li></ul></li> <li>使用方法：
<ul><li>volatile 仅能在变量级别使用。</li> <li>synchronized 则能在方法、普通代码块以及静态代码块级别使用。</li></ul></li> <li>关于三大特性：
<ul><li>volatile 仅能实现可见性和有序性。</li> <li>synchronized 则可以实现可见性、有序性以及原子性。</li></ul></li> <li>是否阻塞：
<ul><li>volatile 不会造成线程阻塞。</li> <li>synchronized 会造成线程阻塞。</li></ul></li> <li>是否被编译器优化：
<ul><li>voaltile 修饰的变量不会被编译器优化。</li> <li>synchronized 标记的变量可以被编译器优化。</li></ul></li></ol> <h2 id="_4-synchronized-详解"><a href="#_4-synchronized-详解" class="header-anchor">#</a> 4. synchronized 详解</h2> <p>在多线程并发编程中 synchronized 一直是元老级角色，很多人称呼它为重量级锁。但是 Java 1.6 对其进行优化之后，它的性能得到显著提升。Java 1.6 优化 synchronized 时，为了减少获得锁和释放锁时候性能的消耗引入了偏向锁、轻量级锁以及锁的存储结构和升级过程。</p> <h3 id="_4-1-synchronized-的应用及其实现原理"><a href="#_4-1-synchronized-的应用及其实现原理" class="header-anchor">#</a> 4.1 synchronized 的应用及其实现原理</h3> <p><strong>synchronized 实现同步的基础：Java 中每一个对象都可以作为锁。</strong></p> <h4 id="_4-1-1-synchronized-的三种应用方式"><a href="#_4-1-1-synchronized-的三种应用方式" class="header-anchor">#</a> 4.1.1 synchronized 的三种应用方式：</h4> <ul><li><p>修饰普通方法：锁是当前实例对象。进入同步方法前，需要获得当前<strong>对象实例的锁</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">normalMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>修饰静态方法：锁是当前类的类对象。进入静态同步方法前，需要获得当前<strong>类对象的锁</strong>。也就是给当前类加锁，会作用于当前类的所有成员。由于静态成员不属于任何对象实例的成员，而是属于类成员，因此可以使用类对象控制静态方法的并发访问。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>修饰代码块：锁可以是当前实例对象，也可以是类对象，也可以是其他对象。进入同步代码块前，需要获得<strong>给定对象的锁</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">codeBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 锁定实例对象</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 锁定类对象</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SynchronizedDemo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 锁定任何给定的对象</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="_4-1-2-实现原理"><a href="#_4-1-2-实现原理" class="header-anchor">#</a> 4.1.2 实现原理</h4> <p>从 JVM 规范中可以看到 synchronized 在 JVM 中的实现原理。JVM 基于<strong>进入和退出 monitor 对象</strong>来实现方法同步和代码块同步，但是二者的实现细节略有不同。</p> <ul><li><p>代码块同步是<strong>基于 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的</strong>。</p> <p><code>monitorenter</code> 指令是在编译后插入到同步代码块开始位置，<code>monitorexit</code> 是插入到代码块结束处和异常处，JVM 要保证每个 <code>monitorenter</code> 必须有对应的 <code>monitorexit</code> 与之配对。线程执行到 <code>monitorenter</code> 指令时，将会尝试获取对象对应的 <code>monitor</code> 的所有权，即尝试获取对象的锁。</p> <ul><li>monitorenter
<ol><li>如果 monitor 的进入数为 0，则该线程进入并占用 monitor，然后将进入数设置为 1，该线程即为 monitor 的所有者。</li> <li>如果线程已经占有了 monitor，只是重新进入，则该 monitor 进入数加 1。</li> <li>如果 monitor 已经被其他线程占用，则该线程进入阻塞状态，直到 monitor 的进入数为 0，再尝试获取 monitor 的所有权。</li></ol></li> <li>monitorexit
<ol><li>执行 monitorexit 的线程必须是所对应 monitorenter 的所有者。</li> <li>执行指令时，monitor 进入数减 1，如果减 1 后进入数为 0，则线程退出 monitor 该线程不再是这个 monitor 的所有者。其他被这个 monitor 阻塞线程尝试获取该 monitor 所有权。</li></ol></li></ul></li> <li><p>方法同步是基于常量池中的 <code>ACC_SYNCHRONIZED</code> 标识符实现的。</p> <p>当方法调用的时候，调用指令会检查 <code>ACC_SYNCHRONIZED</code> 访问标示是否被设置。如果设置了，执行线程将优先获取 <code>monitor</code>，获取成功之后才能执行方法体，方法体执行完后释放 <code>monitor</code>。在方法执行期间，其他线程将无法再获取同一个 <code>monitor</code> 对象。</p></li></ul> <blockquote><p>每个对象都有一个监视器锁（monitor）。当 monitor 被占用的时候，对象就会处于锁定状态。而没有获得监视器的线程将会阻塞在同步方法和同步块的入口处，进入 Blocked 状态。</p> <p>monitor 对象其实就是使用管程控制同步访问的一种对象。</p> <blockquote><p>任何对象都关联了一个管程，管程就是控制对象并发访问的一种机制。</p> <p>管程是一种同步原语，可以理解为 synchronized 就是 Java 中对管程的实现。</p> <blockquote><p>管程锁定规则就是无论单线程还是多线程环境，对同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁能看到前一个线程的操作结果。</p></blockquote></blockquote></blockquote> <p>任意线程对 Object 的访问，首先要获取该 Object 的监视器。如果获取失败，该线程进入同步队列，线程状态为 Blocked。当持有 Object 监视器的线程释放了锁，释放操作则会唤醒阻塞在同步队列中的线程，使其重新尝试获取该 Object 的监视器。对象、对象的监视器、同步队列和执行线程之间的关系如下图所示：</p> <p><img src="/vssue-comment/assets/img/monitor.a89fbe64.png" alt=""></p> <h3 id="_4-2-java-对象头"><a href="#_4-2-java-对象头" class="header-anchor">#</a> 4.2 Java 对象头</h3> <p>synchronized 用的锁被存储在 Java 对象头中。如果对象是数组类型用 3 个字宽（Word）存储对象头，如果对象是非数组类型，则用 2 个字宽存储对象头。（在 32 位虚拟机中，1 字宽等于 4 字节。）</p> <blockquote><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：</p> <ul><li>对象头（Header）：对象头又包含以下两部分信息
<ul><li><strong>Mark Word</strong>：存储对象自身的运行时数据。如哈希码（Hashcode）、GC 分代年龄、锁状态标示、线程持有的锁、偏向的线程 ID等，这部分数据长度在 32 位虚拟机中为 32 bit，在 64 位虚拟机中是 64 bit。</li> <li>类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类。（查找对象的元数据信息并不一定要通过对象本身，所以并不是所有虚拟机的实现都必须在对象数据上保留类型指针。）</li> <li>数组长度：如果是数组类型还会保存数组长度。</li></ul></li> <li>实例数据（Instance Data）</li> <li>对其填充（Padding）</li></ul></blockquote> <p>可以看到在 Mark Word 中存储了关于锁的一些信息，重点来看一下 Mark Word。在运行期间，Mark Word 里存储的数据会随时锁标志位的变化而变化（以 32 位虚拟机为例）：</p> <p><img src="/vssue-comment/assets/img/markword.94618394.png" alt=""></p> <h3 id="_4-3-锁升级-一种锁优化策略"><a href="#_4-3-锁升级-一种锁优化策略" class="header-anchor">#</a> 4.3 锁升级（一种锁优化策略）</h3> <p>锁一共有四种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁一旦从偏向锁升级成轻量级锁后，不能降级成为偏向锁。这种只能升级不能降级的策略，是为了提高获得锁和释放锁的效率。</p> <h4 id="_4-3-1-无锁"><a href="#_4-3-1-无锁" class="header-anchor">#</a> 4.3.1 无锁</h4> <p>无锁的特点就是在循环内进行修改操作，线程会不断的尝试修改操作，直到成功修改资源并退出循环。自旋 CAS 就是无锁修改资源的实现。</p> <h4 id="_4-3-2-偏向锁"><a href="#_4-3-2-偏向锁" class="header-anchor">#</a> 4.3.2 偏向锁</h4> <p>HotSpot 作者经过大量的研究发现，大多数情况下，多线程中锁不仅不存在竞争，而且总是被同一线程多次获得。为了让线程获得锁的代价更低而引入了偏向锁。</p> <ul><li><p>偏向锁获取过程：</p> <ol><li>线程访问同步代码块时，首先会检查对象头 Mark Word 锁标志位，判断目前对象的锁状态。如果是 01，说明是无锁或者偏向锁。然后再根据是否偏向锁的标识位判断是无锁还是偏向锁。如果是偏向锁，判断 Mark Word 中记录的是否为当前线程，如果是直接执行代码块。如果是无锁执行下一步；</li> <li>线程尝试使用 CAS 操作将对象头的偏向锁指向当前线程。如果成功那么当前线程获取对象的偏向锁，并在 Mark Word 中记录获取锁的时间 Epoch 等信息。然后执行代码块。</li></ol> <p>等到下一个线程访问同步代码块锁时，只需要简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果是，以后该线程进入和退出同步代码块时，不需要进行 CAS 操作来加锁或者解锁。</p></li> <li><p>偏向锁的撤销：</p> <p>偏向锁使用等待竞争出现才释放锁的机制。当有其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。</p></li> <li><p>关闭偏向锁：</p> <p>偏向锁默认开启，但是在应用程序启动几秒后才延迟激活。</p> <ul><li>可以使用 JVM 参数 <code>-XX:BiasedLockingStartupDelay=0</code>，关闭延迟，使它立即激活。</li> <li>也可以使用 JVM 参数 <code>-XX:-UseBiasedLocking=false</code>，直接关闭偏向锁，默认直接进入轻量级锁。</li></ul></li></ul> <h4 id="_4-3-3-轻量级锁"><a href="#_4-3-3-轻量级锁" class="header-anchor">#</a> 4.3.3 轻量级锁</h4> <p>轻量级锁是指当前线程持有的锁是偏向锁的时候，如果资源被其他线程所访问且当前线程还处于活动状态，那么偏向锁就会升级为轻量级锁。</p> <ul><li><p>加锁</p> <ol><li>首先 Displaced Mark Word，即线程在执行同步块之前，JVM 会先在当前线程的栈帧中创建拥有存储锁记录的空间，并将对象头中 Mark Word 复制到锁记录中。</li> <li>然后线程尝试使用自旋 CAS 操作将对象头中的 Mark Word 替换为指向栈中锁记录的指针。如果成功，当前线程获得锁。</li></ol></li> <li><p>解锁</p> <p>轻量级锁会主动解锁。当解锁时，使用 CAS 操作将 Displaced Mark Word 替换到对象头，如果成功表示没有线程竞争，解锁成功。如果失败，标示当前锁存在竞争，锁膨胀为重量级锁。</p></li></ul> <h4 id="_4-3-4-重量级锁"><a href="#_4-3-4-重量级锁" class="header-anchor">#</a> 4.3.4 重量级锁</h4> <p>当锁处于这种状态时，其他线程试图获取锁的时候，都会被阻塞，当持有锁的线程释放锁之后会唤醒这些线程。被唤醒的线程进入新一轮的夺锁之争。</p> <h4 id="_4-3-5-不同锁的优缺点及适用场景"><a href="#_4-3-5-不同锁的优缺点及适用场景" class="header-anchor">#</a> 4.3.5 不同锁的优缺点及适用场景</h4> <table><thead><tr><th>锁</th> <th>适用场景</th> <th>优点</th> <th>缺点</th></tr></thead> <tbody><tr><td>偏向锁</td> <td>只有一个线程访问同步代码块</td> <td>加锁、解锁消耗小</td> <td>如果线程间存在锁竞争，<br>会带来额外的锁撤销的消耗</td></tr> <tr><td>轻量级锁</td> <td>追求响应时间</td> <td>竞争的线程不会阻塞，<br>提高程序响应时间</td> <td>始终得不到锁的竞争线程，<br>会使用自旋消耗 CPU</td></tr> <tr><td>重量级锁</td> <td>追求吞吐量</td> <td>竞争的线程不使用自旋，<br>不会消耗 CPU</td> <td>线程阻塞，响应时间缓慢</td></tr></tbody></table> <h2 id="_5-锁优化"><a href="#_5-锁优化" class="header-anchor">#</a> 5. 锁优化</h2> <h3 id="_5-1-锁粗化"><a href="#_5-1-锁粗化" class="header-anchor">#</a> 5.1 锁粗化</h3> <p>一系列连续的操作都对同一个对象反复的加锁和解锁，频繁的进行互斥同步操作就会导致不必要的性能损耗，为了提升性能，扩展成为一个范围更大的锁，就叫做锁粗化。</p> <blockquote><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小，这让做的目的是让需要同步的操作尽可能少，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。但是连续的加锁、解锁是一个非常消耗性能的操作。为了减少性能损耗，引入了锁粗化的概念。</p></blockquote> <h3 id="_5-2-锁消除"><a href="#_5-2-锁消除" class="header-anchor">#</a> 5.2 锁消除</h3> <p>Java 虚拟机在 JIT 编译时，对一些代码上要求同步，但是<strong>不可能存在竞争共享资源</strong>的锁进行消除，就叫做锁消除。</p> <h3 id="_5-3-自旋锁与自适应锁"><a href="#_5-3-自旋锁与自适应锁" class="header-anchor">#</a> 5.3 自旋锁与自适应锁</h3> <p>参考 1.5</p> <h3 id="_5-4-锁升级"><a href="#_5-4-锁升级" class="header-anchor">#</a> 5.4 锁升级</h3> <p>参考 4.3</p> <h2 id="_6-锁"><a href="#_6-锁" class="header-anchor">#</a> 6. 锁</h2> <p>锁式控制多线程访问共享资源的一种方式，一般来说，一个锁能防止多个线程同时访问共享资源（有些锁允许多个线程并发访问共享资源，例如读写锁）。Java 中使用 synchronized 关键字和 Lock 接口实现锁功能。</p> <ul><li><p>synchronized：可重入，不可中断，非公平</p> <blockquote><p>在 Java 5 前，当一个线程获取不到锁，而被阻塞在 synchronized 之外时（即等待状态的线程），对线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会被阻塞在 synchronized 上，直到获取锁。所以等待状态的线程是不可中断的。当它获取锁之后，是可以被中断的。</p></blockquote></li> <li><p>lock 接口：可重入，可中断，公平锁（可以通过构造方法指定是否为公平锁）</p></li></ul> <h3 id="_6-1-锁定义"><a href="#_6-1-锁定义" class="header-anchor">#</a> 6.1 锁定义</h3> <p>众所周知，锁可以让临界区（存在数据竞争的代码片段）互斥执行。</p> <p>锁是并发编程的重要同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p> <h3 id="_6-2-锁的内存语义"><a href="#_6-2-锁的内存语义" class="header-anchor">#</a> 6.2 锁的内存语义</h3> <p>锁释放的内存语义：当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p> <p>锁获取的内存语义：当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。</p> <p>总结：</p> <ul><li>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这把锁的某个线程发出了消息（共享变量所做的修改）。</li> <li>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的消息（共享变量所做的修改）。</li> <li>线程 A 释放锁，随后线程 B 获取锁，实质上是线程 A 通过主内存向线程 B 发送消息。</li></ul> <blockquote><p>锁释放与 volatile 写有相同的语义。锁获取与 volatile 读有相同的语义。</p></blockquote> <h3 id="_6-3-死锁"><a href="#_6-3-死锁" class="header-anchor">#</a> 6.3 死锁</h3> <p>某个线程拿到锁之后，无法释放锁，就叫做死锁。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">DeadLockDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">deadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;AB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;BA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>避免死锁的常见方法：</p> <ul><li>避免一个线程同时获取多个锁。</li> <li>避免一个线程在锁内同时占用多个资源，尽量保证一个锁占用一个资源。</li> <li>尝试使用定时锁。</li> <li>对于数据库锁，加锁和解锁必须在一个数据可连接里，否则会出现解锁失败的情况。</li></ul> <h3 id="_6-4-锁的实现"><a href="#_6-4-锁的实现" class="header-anchor">#</a> 6.4 锁的实现</h3> <p>Java 队列同步器框架（AbstractQueuedSynchronizer，AQS）。AQS 使用一个整型的 volatile 变量（命名为 state）来维护同步状态。</p> <p>公平锁在释放锁的最后写 volatile 变量 state，在获取锁时首先读这个 volatile 变量。</p> <blockquote><p>根据在 JMM 中规定 Happens-before 原则的 volatile 变量规则（对于一个 volatile 变量的写操作先行发生于对这个变量的读操作），释放锁的线程在写 volatile 变量之前可见的其他共享变量（此处不包含 state 变量），在获取锁的线程读取同一个 volatile 变量后将立即变得对获取锁线程可见。</p></blockquote> <p>非公平锁也是在释放锁的最后写 volatile 变量 state，但是在获取锁时是以 CAS 方式更新 state 变量。</p> <p>Lock 接口的实现基本都是通过聚合一个同步器（AQS）的子类来完成线程访问控制的。</p> <p>Lock 接口详见 AQS 章节。</p> <h3 id="_6-5-concurrent-包的实现"><a href="#_6-5-concurrent-包的实现" class="header-anchor">#</a> 6.5 Concurrent 包的实现</h3> <p>volatile 变量的读-写和 CAS 可以实现线程之间的通信，是 concurrent 包实现的基础。</p> <p>一个通用的实现模版：</p> <ol><li>声明一个 volatile 的共享变量</li> <li>使用 CAS 实现线程之间的同步</li> <li>配合 volatile 的读-写和 CAS 实现线程间的通信</li></ol> <p>AQS、非阻塞数据结构和原子变量类都是使用这种模式实现的，而 concurrent 包中的高层类又是基于这些基础类实现的。</p> <p><img src="/vssue-comment/assets/img/concurrent.0d53711e.png" alt=""></p> <p>concurrent 包中的类：</p> <p><img src="/vssue-comment/assets/img/concurrentpackage.50885aeb.png" alt=""></p> <p>参考：</p> <p>https://zhuanlan.zhihu.com/p/137261781</p> <p>https://zhuanlan.zhihu.com/p/101430930</p> <p>https://zhuanlan.zhihu.com/p/65240318</p> <p>https://mp.weixin.qq.com/s/eKksisOytAz4_4Oq_QZPGQ</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-cas-详解" title="1. CAS 详解">1. CAS 详解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-1-cas-原理" title="1.1 CAS 原理">1.1 CAS 原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-2-cas-缺点" title="1.2 CAS 缺点">1.2 CAS 缺点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-3-cas-的优点" title="1.3 CAS 的优点">1.3 CAS 的优点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-4-java-对-cas-的支持" title="1.4 Java 对 CAS 的支持">1.4 Java 对 CAS 的支持</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1-5-自旋锁-一种锁优化策略" title="1.5 自旋锁（一种锁优化策略）">1.5 自旋锁（一种锁优化策略）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-原子操作" title="2. 原子操作">2. 原子操作</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-1-cpu-如何实现原子操作" title="2.1 CPU 如何实现原子操作">2.1 CPU 如何实现原子操作</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2-2-java-如何实现原子操作" title="2.2 Java 如何实现原子操作">2.2 Java 如何实现原子操作</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-volatile-详解" title="3. volatile 详解">3. volatile 详解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-volatile-是什么" title="3.1 volatile 是什么">3.1 volatile 是什么</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-volatile-写-读的内存语义" title="3.2 volatile 写-读的内存语义">3.2 volatile 写-读的内存语义</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-3-volaitle-的两个特性及实现原理" title="3.3 volaitle 的两个特性及实现原理">3.3 volaitle 的两个特性及实现原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-4-volatile-不适用的场景" title="3.4 volatile 不适用的场景">3.4 volatile 不适用的场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-5-volatile-与-synchronized-的区别" title="3.5 volatile 与 synchronized 的区别">3.5 volatile 与 synchronized 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_4-synchronized-详解" title="4. synchronized 详解">4. synchronized 详解</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-1-synchronized-的应用及其实现原理" title="4.1 synchronized 的应用及其实现原理">4.1 synchronized 的应用及其实现原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-2-java-对象头" title="4.2 Java 对象头">4.2 Java 对象头</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-3-锁升级-一种锁优化策略" title="4.3 锁升级（一种锁优化策略）">4.3 锁升级（一种锁优化策略）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_5-锁优化" title="5. 锁优化">5. 锁优化</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-1-锁粗化" title="5.1 锁粗化">5.1 锁粗化</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-2-锁消除" title="5.2 锁消除">5.2 锁消除</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-3-自旋锁与自适应锁" title="5.3 自旋锁与自适应锁">5.3 自旋锁与自适应锁</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_5-4-锁升级" title="5.4 锁升级">5.4 锁升级</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_6-锁" title="6. 锁">6. 锁</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-1-锁定义" title="6.1 锁定义">6.1 锁定义</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-2-锁的内存语义" title="6.2 锁的内存语义">6.2 锁的内存语义</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-3-死锁" title="6.3 死锁">6.3 死锁</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-4-锁的实现" title="6.4 锁的实现">6.4 锁的实现</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_6-5-concurrent-包的实现" title="6.5 Concurrent 包的实现">6.5 Concurrent 包的实现</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>Privacy Policy</a></li><li class="copyright-item" data-v-3d9deeb8>MIT Licensed | Copyright © 2018-present Vue.js</li></ul></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/vssue-comment/assets/js/app.9fa4f4bb.js" defer></script><script src="/vssue-comment/assets/js/13.044f1fde.js" defer></script><script src="/vssue-comment/assets/js/3.f0de84e7.js" defer></script><script src="/vssue-comment/assets/js/12.d7671ee7.js" defer></script>
  </body>
</html>
