<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 内存模型（Java Memory Model，JMM）与指令重排序 | Ni&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="$page.excerpt">
    
    <link rel="preload" href="/vssue-comment/assets/css/0.styles.02c2761a.css" as="style"><link rel="preload" href="/vssue-comment/assets/js/app.9fa4f4bb.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/13.044f1fde.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/3.f0de84e7.js" as="script"><link rel="preload" href="/vssue-comment/assets/js/14.399fc32e.js" as="script"><link rel="prefetch" href="/vssue-comment/assets/js/10.23cc3d6b.js"><link rel="prefetch" href="/vssue-comment/assets/js/11.c63e2dcc.js"><link rel="prefetch" href="/vssue-comment/assets/js/12.d7671ee7.js"><link rel="prefetch" href="/vssue-comment/assets/js/15.37bef016.js"><link rel="prefetch" href="/vssue-comment/assets/js/16.2ae3cc61.js"><link rel="prefetch" href="/vssue-comment/assets/js/17.10c0352f.js"><link rel="prefetch" href="/vssue-comment/assets/js/18.02aac107.js"><link rel="prefetch" href="/vssue-comment/assets/js/19.ac0b8b1d.js"><link rel="prefetch" href="/vssue-comment/assets/js/20.656ccc17.js"><link rel="prefetch" href="/vssue-comment/assets/js/21.d1f01d1a.js"><link rel="prefetch" href="/vssue-comment/assets/js/22.6e251d71.js"><link rel="prefetch" href="/vssue-comment/assets/js/23.caaa7b12.js"><link rel="prefetch" href="/vssue-comment/assets/js/24.33d428f1.js"><link rel="prefetch" href="/vssue-comment/assets/js/25.207f6b5f.js"><link rel="prefetch" href="/vssue-comment/assets/js/26.398d8fee.js"><link rel="prefetch" href="/vssue-comment/assets/js/27.d4ae83e5.js"><link rel="prefetch" href="/vssue-comment/assets/js/28.66c58624.js"><link rel="prefetch" href="/vssue-comment/assets/js/29.a6686645.js"><link rel="prefetch" href="/vssue-comment/assets/js/30.242e18b7.js"><link rel="prefetch" href="/vssue-comment/assets/js/31.7da4eecc.js"><link rel="prefetch" href="/vssue-comment/assets/js/32.9b8f3ea0.js"><link rel="prefetch" href="/vssue-comment/assets/js/33.075dbe36.js"><link rel="prefetch" href="/vssue-comment/assets/js/34.838ce186.js"><link rel="prefetch" href="/vssue-comment/assets/js/35.3bbd155f.js"><link rel="prefetch" href="/vssue-comment/assets/js/36.a07ab564.js"><link rel="prefetch" href="/vssue-comment/assets/js/37.50ef72a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/38.75b498ed.js"><link rel="prefetch" href="/vssue-comment/assets/js/39.3b1e3afb.js"><link rel="prefetch" href="/vssue-comment/assets/js/4.79c2a3ee.js"><link rel="prefetch" href="/vssue-comment/assets/js/40.0a6fdf1b.js"><link rel="prefetch" href="/vssue-comment/assets/js/41.9be8ec60.js"><link rel="prefetch" href="/vssue-comment/assets/js/42.9ce4d2b3.js"><link rel="prefetch" href="/vssue-comment/assets/js/43.c76f9c55.js"><link rel="prefetch" href="/vssue-comment/assets/js/44.4749cc3b.js"><link rel="prefetch" href="/vssue-comment/assets/js/45.605778e4.js"><link rel="prefetch" href="/vssue-comment/assets/js/46.fd2913a3.js"><link rel="prefetch" href="/vssue-comment/assets/js/47.5b787534.js"><link rel="prefetch" href="/vssue-comment/assets/js/48.7cf6064e.js"><link rel="prefetch" href="/vssue-comment/assets/js/49.ffa11e3d.js"><link rel="prefetch" href="/vssue-comment/assets/js/5.6a98c4eb.js"><link rel="prefetch" href="/vssue-comment/assets/js/50.69284de8.js"><link rel="prefetch" href="/vssue-comment/assets/js/6.0cbbe057.js"><link rel="prefetch" href="/vssue-comment/assets/js/7.feaf1269.js"><link rel="prefetch" href="/vssue-comment/assets/js/8.9c40e8a4.js"><link rel="prefetch" href="/vssue-comment/assets/js/9.b2c8bfda.js"><link rel="prefetch" href="/vssue-comment/assets/js/vuejs-paginate.8412c6fc.js">
    <link rel="stylesheet" href="/vssue-comment/assets/css/0.styles.02c2761a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/vssue-comment/" class="nav-link home-link">Ni's Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/vssue-comment/" class="nav-link mobile-home-link">Ni's Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/vssue-comment/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/vssue-comment/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Java 内存模型（Java Memory Model，JMM）与指令重排序
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Ni</span> <span itemprop="address">   in 大连</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-06-28 13:00:00+0800">
      Mon Jun 28 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/vssue-comment/tag/Java" data-v-42ccfcd5><span data-v-42ccfcd5>Java</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>并发处理的广泛应用使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类 “压榨” 计算机运算能力的最有力武器。</p> <blockquote><p>Amdahl定律：通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力。</p> <p>摩尔定律：描述处理器晶体管数量与运行效率之间的发展关系。</p></blockquote> <p>这两个定律的更迭也代表了近年来处理器发展从追求频率到追求多核心并行处理的发展过程。</p> <p>将通过以下内容来阐述 Java 是如何解决 <strong>并发编程中的两个关键问题</strong>：</p> <ul><li>Java 内存模型</li> <li>指令重排序</li></ul> <p>目录：</p> <div><ul><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_1-幕后的故事">1. 幕后的故事</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_2-并发编程的两个关键问题-为什么需要-jmm">2. 并发编程的两个关键问题（为什么需要 JMM）</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_3-java-内存模型">3. Java 内存模型</a><ul><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_3-1-jmm-结构">3.1  JMM 结构</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_3-2-内存间的交互操作、规则">3.2 内存间的交互操作、规则</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_3-3-happens-before-原则">3.3 Happens-Before 原则</a></li></ul></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_4-指令重排序">4. 指令重排序</a><ul><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_4-1-三种重排序的场景">4.1 三种重排序的场景</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_4-2-指令重排序的原则-as-if-serial-语义">4.2 指令重排序的原则：as-if-serial 语义</a></li><li><a href="/vssue-comment/2021/06/28/_02-jmm/#_4-3-多线程中的指令重排序">4.3 多线程中的指令重排序</a></li></ul></li></ul></div> <h2 id="_1-幕后的故事"><a href="#_1-幕后的故事" class="header-anchor">#</a> 1. 幕后的故事</h2> <p>随着科技的进步，CPU、内存（Memory）、磁盘（Storage）都在不断的迭代，朝着更快的方向发展。但是有一个核心矛盾一直不能解决，就是三者的速度差异。</p> <p>CPU 和 内存的速度差异可以形象的描述为：CPU 是天上一天，内存是地上一年。假设 CPU 执行一条指令需要一天的时间，那么 CPU 去读取内存的时间就是一年。内存和磁盘的速度差异更大：内存天上一天，磁盘地下十年。</p> <p>程序中绝大部分运算任务都不可能只靠 CPU 计算完成，CPU 至少要与内存交互，如读取运算数据、存储运算结果等，这些 I/O 操作很难消除（无法仅靠寄存器完成所有的运算任务）。所以现在计算机系统都加入一层读写速度尽可能接近 CPU 运算速度的<strong>高速缓存</strong>（<strong>Cache</strong>）来作为 CPU 和内存之间的缓冲：<strong>将运算需要使用到的数据从内存复制到缓存中，让运算快速进行，当运算结束后再从缓存同步到内存之中</strong>。这样处理器就无需等待缓慢的内存读写了。</p> <p><img src="/vssue-comment/assets/img/cpu_memory.c47da250.png" alt=""></p> <p>通过以上你觉得事情就变的完美了吗？并没有！它引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。在多处理器系统中，每个处理器都有自己的高速缓存，而这些处理器又共享同一主内存（Main Memory）。当多个处理器的运算任务涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性问题，需要各个处理器访问缓存时遵循一些协议。<strong>内存模型</strong>就是在特定协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p> <h2 id="_2-并发编程的两个关键问题-为什么需要-jmm"><a href="#_2-并发编程的两个关键问题-为什么需要-jmm" class="header-anchor">#</a> 2. 并发编程的两个关键问题（为什么需要 JMM）</h2> <p>并发编程中两个关键问题：</p> <ol><li>线程之间如何通信。（通信：线程之间交换信息的机制。）</li> <li>线程之间如何同步。（同步：线程之间操作发生相对顺序的机制。通俗的讲，当一个线程对某块内存进行操作时，其他线程都不可以对这块内存地址进行操作，直到该线程完成操作。）</li></ol> <p>线程之间的通信机制有两种：<strong>共享内存和消息传递。</strong></p> <ul><li>在共享内存并发模型中：
<ul><li>由于线程之间存在公共状态，通过写-读内存中的公共状态，所以线程间通信总是隐式进行。</li> <li>程序员必须明确指定某段代码或某个方法需要在线程之间互斥执行，所以线程间同步总是显示进行。</li></ul></li> <li>在消息传递并发模型中：
<ul><li>由于没有公共状态，必须通过发送消息进行通信，所以线程间通信总是显示进行。</li> <li>由于消息的发送必须在消息的接受之前，所以线程间同步总是隐式进行。</li></ul></li></ul> <p>Java 并发采用共享内存模型，由于线程间通信时隐时进行的，程序员完成感知不到，所以需要了解其机制，以防内存可见性的问题，从而编写正确的同步代码。</p> <p>再讲内存可见性问题：<strong>当一个线程更新共享变量的值后，其他线程没有及时的看到该共享变量最新的值</strong>。</p> <p>共享变量：代指实例域、静态域和数组元素。</p> <p>局部变量、方法定义参数和异常处理器参数不会在线程之间共享，他们不会有内存可见性的问题，也不受内存模型影响。</p> <h2 id="_3-java-内存模型"><a href="#_3-java-内存模型" class="header-anchor">#</a> 3. Java 内存模型</h2> <h3 id="_3-1-jmm-结构"><a href="#_3-1-jmm-结构" class="header-anchor">#</a> 3.1  JMM 结构</h3> <p>JVM 规范中定义了 Java 内存模型（Java Memory Model，JMM）。</p> <blockquote><p>（需要跟 JVM 内存模式区分开来，JVM 内存模式是 JVM 的内存分区。JMM 是一种虚拟机规范。）</p></blockquote> <p>JMM 定义了线程和主内存之间的抽象关系：</p> <ul><li>线程之间的共享变量存储在主内存（Main Memory）中。</li> <li>每个线程都有一个私有的本地内存（Local Memory），也叫工作内存（Work Memory）。不同线程无法访问对方的本地内存。</li> <li>本地内存中存储了共享变量的副本。</li> <li>线程对共享变量的所有操作都必须在本地内存中进行。</li> <li>线程间共享变量值的传递必须通过主内存来完成。</li></ul> <p>JMM 抽象结构示意图：</p> <p><img src="/vssue-comment/assets/img/JMM.5bb42de3.png" alt=""></p> <p>JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。从上图来看，线程 A 和线程 B 之间通信的话，必须经历以下两个步骤：</p> <ol><li>线程 A 把本地内存 A 中更新过的共享变量的副本刷新到主内存的共享变量中去。</li> <li>线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量到本地内存 B 的共享变量的副本中。</li></ol> <p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而这个通信过程需要要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p> <p>补充：</p> <p>本地内存是 JMM 的一个抽象概念，并不实际存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p> <p>这里的主内存、本地内存与 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上没有任何关系，如果一定要勉强对应起来，主内存主要对应与 Java 堆中的对象实例部分，而本地内存则对应虚拟机栈中的部分区域。</p> <p>JVM 采用内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现让 Java 程序员在各种平台下达到一致的内存访问效果。比如 C 语言中的整型变量，在有的平台中占用两个字节的内存，有的平台中占用四个字节的内存，Java 则在任何平台下，int 类型就是四个字节内存，这就是所谓的一致的内存访问效果。</p> <h3 id="_3-2-内存间的交互操作、规则"><a href="#_3-2-内存间的交互操作、规则" class="header-anchor">#</a> 3.2 内存间的交互操作、规则</h3> <p>关于主内存和本地内存之间的交互协议（一个变量如何从主内存拷贝到本地内存、如何从本地内存同步回主内存之间的实现细节），JMM 定义了 8 种操作来完成。虚拟机实现时必须抱保证每一个操作都是原子的、不可再分的（double 和 long 类型变量例外，它们占用 8 个字节内存，在 32 位虚拟机和 64 位虚拟机中表现不同）。</p> <ul><li>lock（锁定）：作用于主内存变量，变量标识为线程独占状态。</li> <li>unlock（解锁）：作用于主内存变量，变量从线程独占状态释放，以被其他线程引用。</li> <li>read（读取）：作用于主内存变量，变量的值从主内存读取到本地内存中。</li> <li>load（载入）：作用于本地内存变量，变量的值从本地内存载入到本地内存的变量副本中。</li> <li>use（使用）：作用于本地内存变量，变量的值从本地内存的变量副本中传递给执行引擎。</li> <li>assign（赋值）：作用于本地内存变量，变量的值从执行引擎赋值给本地内存的变量副本。</li> <li>store（存储）：作用于本地内存变量，变量的值从本地内存存储到主内存中。</li> <li>write（写入）：作用于主内存变量，变量的值从主内存写入到共享变量中。</li></ul> <p>通过以上操作我们可以知道，一个变量从主内存复制到本地内存中，需要顺序的执行 read 和 load 操作；变量从本地内存同步回主内存，需要顺序的执行 store 和 write 操作。JMM 要求只以上两个操作顺序执行，没有要求连续执行。所以，对于两个变量 a 和 b 进行访问的时候可能会出现 read a、read b、load b、load a。除此之外，JMM 还规定在执行上述 8 种操作时必须满足的一些规则：</p> <ul><li>不允许 read 和 load、store 和 write 单独出现。</li> <li>不允许线程丢弃 assign 操作，即变量在本地内存更新之后必须同步回主内存中。</li> <li>不允许无原因（变量在本地内存中未更新）的把数据同步回主内存。</li> <li>新的变量只能在主内存中“诞生”。</li> <li>一个变量在同一时刻只允许一个线程对其进行 lock 操作，可以 lock 多次，当时需要同样次数的 unlock 才能解锁。</li> <li>一个变量执行 lock 操作将会清空本地内存中此变量的值。</li> <li>不允许 unlock 未被 lock 的变量，也不允许 unlock 一个被其他线程 lock 的变量。</li> <li>一个变量执行 unlock 之前，必须先把变量同步回主内存中。</li></ul> <p>通过以上 8 种内存访问规则以及 volatile 关键字的一些特殊规定，可以完全确定 Java 程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨又十分繁琐，实践起来非常麻烦，所有有一个等效判断原则——Happens-before，用来确定一个访问在并发环境下是否安全。</p> <h3 id="_3-3-happens-before-原则"><a href="#_3-3-happens-before-原则" class="header-anchor">#</a> 3.3 Happens-Before 原则</h3> <p>先行发生（Happens-before）原则是 JMM 中定义的两项操作之间的偏序关系。它可以用来指导并发编程的正确性。</p> <blockquote><p>通俗的说，操作 A 先行发生于操作 B，意思就是操作 B 发生之前，操作 A 产生的影响能被操作 B 观察到。</p> <p>“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p></blockquote> <p>通过一个例子来理解 Happens-before：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 此操作线程 A 中执行</span>
i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token comment">// 此操作线程 B 中执行</span>
j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token comment">// 此操作线程 C 中执行</span>
i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
</code></pre></div><p>假设两种情况，来分别分析变量 j 的值：</p> <ol><li>线程 A 和 B 已经启动，且线程 A 先行发生与线程 B，线程 C 还未启动；</li> <li>线程 A、B、C 都已经启动，还是线程 A 先行发生与线程 B，但是线程 B 和 线程 C 之间没有先行发生关系；</li></ol> <ul><li>在情况 1 中，变量 j 的值必然为 5；</li> <li>在情况 2 中，变量 j 的值不确定，5 和 8 都有可能，因为线程 C 的执行时间不确定，有可能在线程 B 之后，也有可能在线程 B 之前，更有可能在线程 A 之前。</li></ul> <p>以下是 JMM 定义的 “天然的” 先行发生关系，这些先行发生无须任何同步器协助就已经存在，在代码中中默认直接使用。如果两个操作之间的关系不在此列，并且无法通过以下规则推导出来，就没有顺序性保证，虚拟机就可以对他们进行随意排序。</p> <ul><li>程序次序规则：<strong>同一线程</strong>内，前面的操作先行发生于后面的操作。</li> <li>管程锁定规则：unlock 操作先行发生于同一个锁的 lock 操作。即，就是无论单线程还是多线程环境，对<strong>同一个锁</strong>来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁能看到前一个线程的操作结果。</li> <li>volatile 变量规则：对于一个 volatile 变量的写操作先行发生于对这个变量的读操作。</li> <li>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的任何其他动作。</li> <li>线程终止规则：线程中的所有操作先行发生于对此线程的终止检测方法。通过 Thread.join()、Thread.isAlive() 等手段检测线程已经终止执行。</li> <li>线程中断规则：Thread 对象的 interrupt() 方法先行发生于 Thread.interrupted() 方法。Thread.interrupted() 方法用于检测线程是否被中断。</li> <li>对象中介规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li> <li>传递性：如果操作 A 先行发生于 操作 B，操作 B 先行发生于 操作 C，那么 操作 A 先行发生于操作 C。</li></ul> <p>结论：时间先后顺序与先行发生原则基本没有太大的关系，所以衡量并发问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p> <h2 id="_4-指令重排序"><a href="#_4-指令重排序" class="header-anchor">#</a> 4. 指令重排序</h2> <p>在 Java 内存模型的幕后故事中，我们了解到为了解决处理器与内存之间速度差异问题，引入了高速缓存（Cache）。其实，除了增加高速缓存之外，为了使处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化。处理器会在计算之后将乱序执行的结果重组，保证该结果和顺序执行的结果是一致的。</p> <p>与处理器乱序执行优化类似，JVM 的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p> <h3 id="_4-1-三种重排序的场景"><a href="#_4-1-三种重排序的场景" class="header-anchor">#</a> 4.1 三种重排序的场景</h3> <p>编译器和处理器为了优化程序性能而对指令序列进行重新排序。三种重排序类型：</p> <ol><li><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li> <li><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li> <li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol> <h3 id="_4-2-指令重排序的原则-as-if-serial-语义"><a href="#_4-2-指令重排序的原则-as-if-serial-语义" class="header-anchor">#</a> 4.2 指令重排序的原则：as-if-serial 语义</h3> <p>串行（as-if-serial）语义：不管怎么重排序，单线程内程序的执行结果不能被改变。编译器、Runtime 和处理器都必须遵守 as-if-serial 语义。</p> <p>为了遵守 as-if-serial 语义，<strong>编译器和处理器不会对存在数据依赖关系的操作做重排序</strong>，因为这种操作会改变执行结果。</p> <h4 id="_4-2-1-数据依赖性"><a href="#_4-2-1-数据依赖性" class="header-anchor">#</a> 4.2.1 数据依赖性</h4> <p>两个操作访问同一个变量，且这两个操作中有一个为写操作，此时两个操作之间存在数据依赖性。</p> <table><thead><tr><th>名称</th> <th>代码实例</th> <th>说明</th></tr></thead> <tbody><tr><td>写后读</td> <td>a = 1;<br>b = a;</td> <td>写一个变量后，再读这个变量</td></tr> <tr><td>写后写</td> <td>a = 1;<br>a = 2;</td> <td>写一个变量后，再写这个变量</td></tr> <tr><td>读后写</td> <td>a = b;<br>b = 1;</td> <td>读一个变量后，再写这个变量</td></tr></tbody></table> <p>上面三种情况，只要重排序任何两个操作的执行顺序，就会改变程序的执行结果。</p> <p>编译器和处理器对操作进行重排序时，会遵守数据依赖性。编译器和处理器不会对存在数据依赖性的两个操作做重排序。因为重排序会改变程序的执行结果。</p> <p>注意：数据依赖性指的是单个处理器中执行的指令序列和单个线程中执行的操作，<strong>不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</strong>。</p> <h4 id="_4-2-2-as-if-serial-语义和-happens-before-规则的区别"><a href="#_4-2-2-as-if-serial-语义和-happens-before-规则的区别" class="header-anchor">#</a> 4.2.2 as-if-serial 语义和 happens-before 规则的区别</h4> <ul><li>as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。</li> <li>as-if-serial 语义给编写单线程程序的程序员创造了一个幻觉：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻觉：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。</li> <li>as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ul> <h3 id="_4-3-多线程中的指令重排序"><a href="#_4-3-多线程中的指令重排序" class="header-anchor">#</a> 4.3 多线程中的指令重排序</h3> <p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p> <p><img src="/vssue-comment/assets/img/instruction_reorder.15cf8451.png" alt=""></p> <p>上图中，1 属于编译器重排序，2 和 3 属于处理器重排序。这些<strong>重排序可能会导致多线程程序出现内存可见性的问题</strong>。</p> <ul><li>对于编译器重排序：<strong>JMM 的编译器重排序规则</strong>会<strong>直接禁止</strong>特定类型的编译器重排序。</li> <li>对于处理器重排序：JMM 的处理器重排序规则会要求 Java 编译器在生成指令时，通过<strong>插入特定类型的内存屏障（Memory Barriers）指令</strong>，来禁止特定类型的处理器重排序。</li></ul> <p>JMM 属于语言级内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p> <h4 id="_4-3-1-内存屏障"><a href="#_4-3-1-内存屏障" class="header-anchor">#</a> 4.3.1 内存屏障</h4> <p>内存屏障（Memory Barriers）：是一组处理器指令，用于实现对内存操作的顺序限制。</p> <p>内存屏障的目的是为了在多 CPU 的情况下保证各 CPU 中缓存的一致性。</p> <blockquote><p>只有一个 CPU 的时候并不需要内存屏障；但如果有两个或者更多 CPU 访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p></blockquote> <p>内存屏障提供的四个功能：</p> <ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置。</li> <li>确保在执行到内存屏障修饰的指令时前面的指令全部执行完成。</li> <li>强制对缓存（线程本地内存）的修改操作立即写入主内存中。</li> <li>如果是写操作，它会导致其他 CPU中的缓存（线程本地内存）无效。（这一点由缓存一致性协议保证）</li></ol> <h4 id="_4-3-2-jmm-对于-volatile-型变量的特殊规则"><a href="#_4-3-2-jmm-对于-volatile-型变量的特殊规则" class="header-anchor">#</a> 4.3.2 JMM 对于 volatile 型变量的特殊规则</h4> <p>关键字 volatile 是 JVM 提供的最轻量级的同步机制。当一个变量定义为 volatile 之后，它具备两种特性：</p> <ul><li>可见性。volatile 变量对所有线程是立即可见的，对 volatile 变量所有的<strong>写操作</strong>都能立即反应到其他线程之中，换句话说，volatile 变量的值在各个线程中是一致的。但是这并不代表 volatile 变量的<strong>运算</strong>在并发中是安全的。所以在以下两条规则的运算中，我们仍然需要通过加锁来保证原子性，进而保证运算在多线程中是安全的：
<ul><li>运算结果依赖于变量当前的值。</li> <li>变量需要与其他状态变量协同工作。</li></ul></li> <li>禁止指令重排序优化。通过在指令序列中<strong>插入内存屏障</strong>来禁止重排序。</li></ul> <p><strong>volatile 和 final 关键字保证可见性的原理都是通过内存屏障实现的</strong>。</p> <p>参考：</p> <p>https://geek-docs.com/java/java-concurrent/concurrent-programming-core-problems.html</p> <p>https://cloud.tencent.com/developer/article/1575509</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-幕后的故事" title="1. 幕后的故事">1. 幕后的故事</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-并发编程的两个关键问题-为什么需要-jmm" title="2. 并发编程的两个关键问题（为什么需要 JMM）">2. 并发编程的两个关键问题（为什么需要 JMM）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-java-内存模型" title="3. Java 内存模型">3. Java 内存模型</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-jmm-结构" title="3.1  JMM 结构">3.1  JMM 结构</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-内存间的交互操作、规则" title="3.2 内存间的交互操作、规则">3.2 内存间的交互操作、规则</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-3-happens-before-原则" title="3.3 Happens-Before 原则">3.3 Happens-Before 原则</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_4-指令重排序" title="4. 指令重排序">4. 指令重排序</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-1-三种重排序的场景" title="4.1 三种重排序的场景">4.1 三种重排序的场景</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-2-指令重排序的原则-as-if-serial-语义" title="4.2 指令重排序的原则：as-if-serial 语义">4.2 指令重排序的原则：as-if-serial 语义</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_4-3-多线程中的指令重排序" title="4.3 多线程中的指令重排序">4.3 多线程中的指令重排序</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8>Privacy Policy</a></li><li class="copyright-item" data-v-3d9deeb8>MIT Licensed | Copyright © 2018-present Vue.js</li></ul></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/vssue-comment/assets/js/app.9fa4f4bb.js" defer></script><script src="/vssue-comment/assets/js/13.044f1fde.js" defer></script><script src="/vssue-comment/assets/js/3.f0de84e7.js" defer></script><script src="/vssue-comment/assets/js/14.399fc32e.js" defer></script>
  </body>
</html>
