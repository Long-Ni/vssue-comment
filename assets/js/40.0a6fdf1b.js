(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{555:function(v,_,t){"use strict";t.r(_);var l=t(8),s=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("一句话介绍各设计模式。")]),v._v(" "),t("p",[v._v("目录：")]),v._v(" "),t("TOC",{attrs:{"include-level":[2,4]}}),v._v(" "),t("h2",{attrs:{id:"创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[v._v("#")]),v._v(" 创建型模式")]),v._v(" "),t("p",[v._v("这类模式提供创建对象的机制。能够提升代码的灵活性和可复用性。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("工厂方法")]),v._v("：由子类决定要创建的具体类是哪一个。")]),v._v(" "),t("li",[v._v("抽象工厂：允许客户创建对象的家族，而无需指定他们的具体类。")]),v._v(" "),t("li",[t("strong",[v._v("单件")]),v._v("：确保有且只有一个对象被创建。")])]),v._v(" "),t("h2",{attrs:{id:"结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[v._v("#")]),v._v(" 结构型模式")]),v._v(" "),t("p",[v._v("这类模式将对象和类组装成较大的结构。能够提升结构的灵活和高效。")]),v._v(" "),t("ul",[t("li",[v._v("适配器：封装对象，并提供不同的接口。")]),v._v(" "),t("li",[v._v("组合：客户用一致方式处理对象集合和单个对象。")]),v._v(" "),t("li",[v._v("装饰者：包装一个对象，以提供新的行为。")]),v._v(" "),t("li",[v._v("外观：简化一群类的接口。")]),v._v(" "),t("li",[t("strong",[v._v("代理")]),v._v("：包装对象，以控制对目标对象的访问。")])]),v._v(" "),t("h2",{attrs:{id:"行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[v._v("#")]),v._v(" 行为型模式")]),v._v(" "),t("p",[v._v("这类模式负责对象之间的高效沟通和职责委派。")]),v._v(" "),t("ul",[t("li",[v._v("命令：封装请求成为对象。")]),v._v(" "),t("li",[v._v("迭代器：在对象的集合之中游走，而不暴露集合的实现。")]),v._v(" "),t("li",[v._v("观察者：让对象能够在状态改变时被通知。")]),v._v(" "),t("li",[v._v("状态：封装了基于状态的行为，并使用委托在行为之间切换。")]),v._v(" "),t("li",[v._v("策略：封装可以互换的行为，并使用委托来决定要使用哪一个。")]),v._v(" "),t("li",[t("strong",[v._v("模板方法")]),v._v("：由子类决定如何实现一个算法中的步骤。")])])],1)}),[],!1,null,null,null);_.default=s.exports}}]);