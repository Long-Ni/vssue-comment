(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{455:function(v,_,t){v.exports=t.p+"assets/img/process_thread.d45c8fc9.png"},456:function(v,_,t){v.exports=t.p+"assets/img/concurrency.80d6d655.png"},457:function(v,_,t){v.exports=t.p+"assets/img/parallel.65935dc4.png"},458:function(v,_,t){v.exports=t.p+"assets/img/parallel_concurrency.1cb009b1.png"},459:function(v,_,t){v.exports=t.p+"assets/img/concurrency_parallel2.5fdf6afa.png"},537:function(v,_,t){"use strict";t.r(_);var r=t(8),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("p",[v._v("一些基础概念解析与区别")]),v._v(" "),r("ul",[r("li",[v._v("进程、线程、多进程、多线程")]),v._v(" "),r("li",[v._v("并发、并行")]),v._v(" "),r("li",[v._v("同步与异步、阻塞与非阻塞")]),v._v(" "),r("li",[v._v("临界资源与临界区")])]),v._v(" "),r("p",[v._v("目录：")]),v._v(" "),r("TOC",{attrs:{"include-level":[2,4]}}),v._v(" "),r("h2",{attrs:{id:"进程-process"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程-process"}},[v._v("#")]),v._v(" 进程（Process）")]),v._v(" "),r("p",[v._v("对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。")]),v._v(" "),r("blockquote",[r("p",[v._v("进程是操作系统资源分配的基本单位。")])]),v._v(" "),r("h2",{attrs:{id:"线程-thread"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程-thread"}},[v._v("#")]),v._v(" 线程（Thread）")]),v._v(" "),r("p",[v._v("有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）")]),v._v(" "),r("blockquote",[r("p",[v._v("线程是 CPU 进行任务调度的基本单位。（真正在 CPU 上运行的是线程）")])]),v._v(" "),r("p",[v._v("由于每个进程至少要干一件事，所以，一个进程至少有一个线程。")]),v._v(" "),r("p",[r("img",{attrs:{src:t(455),alt:""}})]),v._v(" "),r("h2",{attrs:{id:"多进程-multi-process"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多进程-multi-process"}},[v._v("#")]),v._v(" 多进程（Multi-process）")]),v._v(" "),r("p",[v._v("在同一个计算机系统中，同一时刻如果允许两个或者两个以上的进程处于运行状态，就叫做多进程（多任务）。")]),v._v(" "),r("blockquote",[r("ol",[r("li",[v._v("现代操作系统基本都是多任务的。")]),v._v(" "),r("li",[v._v("多进程对系统的资源要求较高，资源浪费比较严重。")]),v._v(" "),r("li",[v._v("多进程比较稳定。因为线程的奔溃会导致进程的奔溃，而一个进程奔溃不会影响另一个进程。")])])]),v._v(" "),r("h2",{attrs:{id:"多线程-multi-thread"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多线程-multi-thread"}},[v._v("#")]),v._v(" 多线程（Multi-thread）")]),v._v(" "),r("p",[v._v("利用多个线程的概念来编程就叫做多线程编程。")]),v._v(" "),r("blockquote",[r("ol",[r("li",[v._v("多线程通过同步完成多项任务，提高了资源的利用效率。（多线程编程的唯一目的）")]),v._v(" "),r("li",[v._v("它是通过提高 CPU 资源使用效率来提高整个系统的效率，而不一定提高程序运行速度。")]),v._v(" "),r("li",[v._v("多个线程“同时”执行各自的任务。同时并非同一时刻，而是在某个时间段内完成多个任务，任务的执行有先后顺序。")])])]),v._v(" "),r("h2",{attrs:{id:"并发-concurrent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发-concurrent"}},[v._v("#")]),v._v(" 并发（Concurrent）")]),v._v(" "),r("p",[v._v("在单个 CPU 上，多个任务（线程）之间要竞争这个 CPU 资源才能得到执行机会。")]),v._v(" "),r("blockquote",[r("ol",[r("li",[v._v("为了同时处理在多个任务，执行期间 CPU 会在多个任务之间切换。")]),v._v(" "),r("li",[v._v("所以多个任务是在同时（宏观）执行的，但不是同一时刻（微观）。")])])]),v._v(" "),r("p",[r("img",{attrs:{src:t(456),alt:""}})]),v._v(" "),r("h2",{attrs:{id:"并行-parallel"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并行-parallel"}},[v._v("#")]),v._v(" 并行（Parallel）")]),v._v(" "),r("p",[v._v("在多个 CPU （或者多核 CPU）上，多个任务不需要竞争就能得到执行机会。")]),v._v(" "),r("blockquote",[r("ol",[r("li",[v._v("真正意义上的同一时刻执行多个任务。")]),v._v(" "),r("li",[v._v("不存在并发那样竞争 CPU 资源、等待执行的情况。因为并行状态下，线程分布在不同的 CPU 上。")])])]),v._v(" "),r("p",[r("img",{attrs:{src:t(457),alt:""}})]),v._v(" "),r("h2",{attrs:{id:"并行并发-parallel-concurrent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并行并发-parallel-concurrent"}},[v._v("#")]),v._v(" 并行并发（Parallel Concurrent ）")]),v._v(" "),r("p",[v._v("线程分布在多个 CPU 上，在同时、同一时刻执行多个任务。")]),v._v(" "),r("blockquote",[r("p",[v._v("在同一 CPU 上执行的线程是并发的。在不同 CPU 上执行的线程是并行的。")])]),v._v(" "),r("p",[r("img",{attrs:{src:t(458),alt:""}})]),v._v(" "),r("p",[v._v("并发与并行都是多线程处理场景。")]),v._v(" "),r("p",[v._v("不管并发还是并行，都是为了提高程序对 CPU 资源的利用率，最大限度的利用 CPU 资源。")]),v._v(" "),r("p",[v._v("最后再放一张经典的图（来源不知名大神），更好的理解并发与并行。")]),v._v(" "),r("p",[r("img",{attrs:{src:t(459),alt:""}})]),v._v(" "),r("h2",{attrs:{id:"同步与异步、阻塞和非阻塞"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步、阻塞和非阻塞"}},[v._v("#")]),v._v(" 同步与异步、阻塞和非阻塞")]),v._v(" "),r("h3",{attrs:{id:"同步-sync-与异步-async"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步-sync-与异步-async"}},[v._v("#")]),v._v(" 同步（Sync）与异步（Async）")]),v._v(" "),r("p",[v._v("同步与异步关注的是"),r("strong",[v._v("消息通信机制")]),v._v("。")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("从线程角度理解：同步与异步指两个线程之间的关系。")]),v._v(" "),r("blockquote",[r("p",[v._v("同步调用：线程 A 对线程 B 发起调用，线程 A 等到线程 B 的结果之后才能继续执行。")]),v._v(" "),r("p",[v._v("异步调用：线程 A 对线程 B 发起调用，不等线程 B 的结果，线程 A 继续执行。线程 B 有了结果主动通知线程 A。")])])]),v._v(" "),r("li",[r("p",[v._v("从 HTTP 请求角度理解：同步与异步主要针对调用者（请求），即 Client 端。")]),v._v(" "),r("blockquote",[r("p",[v._v("同步调用：Client 端程序发起一个调用，在没得到返回之前，程序会一直等到被调用者做出响应，才往下执行。")]),v._v(" "),r("p",[v._v("异步调用：Client 端程序发起一个调用后，程序不用等到被调用者返回结果，就继续往下执行。被调用者返回结果后依靠状态、通知、回调等机制来与调用者通信。")])])])]),v._v(" "),r("h3",{attrs:{id:"阻塞-bolck-与非阻塞-unblock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-bolck-与非阻塞-unblock"}},[v._v("#")]),v._v(" 阻塞（Bolck）与非阻塞（Unblock）")]),v._v(" "),r("p",[v._v("阻塞与非阻塞关注的是"),r("strong",[v._v("程序在等待调用结果（消息或返回值）时的状态")]),v._v("：")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("从线程角度理解：阻塞与非阻塞指单个线程的状态。")]),v._v(" "),r("blockquote",[r("p",[v._v("阻塞执行：线程在发起调用之后被挂起。")]),v._v(" "),r("p",[v._v("非阻塞执行：线程在发起调用之后，去干别的事情。时不时的检查调用结果。")])])]),v._v(" "),r("li",[r("p",[v._v("从 HTTP 请求角度理解：阻塞与非阻塞主要针对被调用者（被请求），即 Server 端。")]),v._v(" "),r("blockquote",[r("p",[v._v("阻塞执行：Server 端程序被调用后，没有计算出结果之前不 Return。")]),v._v(" "),r("p",[v._v("非阻塞执行：Server 端程序被调用后，立即做出响应。实际的返回结果之后通知调用者。")])])])]),v._v(" "),r("h3",{attrs:{id:"四种组合关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四种组合关系"}},[v._v("#")]),v._v(" 四种组合关系")]),v._v(" "),r("p",[v._v("（come soon...）")]),v._v(" "),r("ul",[r("li",[v._v("同步阻塞")]),v._v(" "),r("li",[v._v("同步非阻塞")]),v._v(" "),r("li",[v._v("异步阻塞")]),v._v(" "),r("li",[v._v("异步非阻塞")])]),v._v(" "),r("h2",{attrs:{id:"临界资源与临界区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#临界资源与临界区"}},[v._v("#")]),v._v(" 临界资源与临界区")]),v._v(" "),r("ul",[r("li",[v._v("临界资源：一次仅允许一个进程使用的共享资源。\n"),r("ul",[r("li",[v._v("属于临界资源的硬件：打字机、磁带机等；")]),v._v(" "),r("li",[v._v("属于临界资源的软件：消息队列、缓冲区、数组、变量等。")])])]),v._v(" "),r("li",[v._v("临界区：并发进程中访问临界资源的程序段，叫做临界区。\n"),r("ul",[r("li",[v._v("如果有若干进程要求进入空闲的临界区，一次只允许一个进程进入；")]),v._v(" "),r("li",[v._v("任何时候，处于临界区内的进程不可多于一个；")]),v._v(" "),r("li",[v._v("进入临界区的进程要在有限时间内退出，以便其他进程能及时进入自己的临界区；")]),v._v(" "),r("li",[v._v("如果进程不能进入自己的临界区，则应让出 CPU，避免进程出现 “忙等” 的现象。")])])])]),v._v(" "),r("p",[v._v("参考：")]),v._v(" "),r("p",[v._v("https://www.cnblogs.com/loveer/p/11479249.html")])],1)}),[],!1,null,null,null);_.default=a.exports}}]);