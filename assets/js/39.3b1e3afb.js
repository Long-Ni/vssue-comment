(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{556:function(t,v,_){"use strict";_.r(v);var s=_(8),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("目录：")]),t._v(" "),_("TOC",{attrs:{"include-level":[2,4]}}),t._v(" "),_("h2",{attrs:{id:"工厂方法模式结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式结构"}},[t._v("#")]),t._v(" 工厂方法模式结构")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("产品")]),t._v("：将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("具体产品")]),t._v("：是产品接口的具体实现。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("创建者")]),t._v("：将声明返回产品对象的工厂方法。该方法返回的产品类型必须与产品结构相匹配。")]),t._v(" "),_("p",[t._v("你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。")]),t._v(" "),_("p",[t._v("注意， 尽管它的名字是创建者， 但他最主要的职责并"),_("strong",[t._v("不是")]),t._v("创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。")]),t._v(" "),_("p",[t._v("工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("具体创建者")]),t._v("：重写基础工厂方法，使其返回不同类型产品。")]),t._v(" "),_("p",[t._v("注意，并不是每一次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、对象池或其他来源的已有对象。")])])]),t._v(" "),_("h2",{attrs:{id:"识别方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#识别方法"}},[t._v("#")]),t._v(" 识别方法")]),t._v(" "),_("p",[t._v("工厂方法可以通过构建方法来识别，它会创建具体类的对象，但以抽象类型或接口的形式返回这些对象。")])],1)}),[],!1,null,null,null);v.default=r.exports}}]);