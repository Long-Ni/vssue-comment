(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{524:function(a,t,s){"use strict";s.r(t);var n=s(8),e=function(a){a.options.__data__block__={mermaid_64a567e6:'graph LR;\nA("💰") --\x3eB("支付类工具") --\x3eC("钱包类工具")\n'}},v=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("在交易过程中，Money💰是用来支付的。信用卡、支付宝这些工具也能用来支付，但是信用卡、支付宝这些工具实际上还是拿你的💰去支付的。所以，信用卡、支付宝等工具只是代理了你的💰 。大多数情况下人们为什么不直接拿钱去交易，而是用这类代理工具去交易呢？在实际生活中，如果你用现金交易，那么在交易之前，你要检查自己手头的现金是否足额支付此次交易，如不够，你得先去银行取钱。在交易之后，如果剩余的数额较大，还需要去银行将这部分存入你自己的账户等等。这很繁琐。但是如果你用信用卡、支付宝这类代理工具去做交易，代理工具就会帮你做好交易之前和之后要做的事，而你只需要专注于交易即可。")]),a._v(" "),s("p",[a._v("在这个例子中，我们将💰称之为"),s("strong",[a._v("目标对象")]),a._v("，信用卡、支付宝这类的工具称之为"),s("strong",[a._v("代理对象")]),a._v("。（这很重要！！！）")]),a._v(" "),s("p",[a._v("目录：")]),a._v(" "),s("TOC",{attrs:{"include-level":[2,4]}}),a._v(" "),s("h3",{attrs:{id:"_1-什么是代理模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是代理模式"}},[a._v("#")]),a._v(" 1. 什么是代理模式")]),a._v(" "),s("p",[s("strong",[a._v("代理模式")]),a._v("是一种结构型设计模式， 让你能够提供目标对象的替代品或其占位符（代理对象），以控制对目标对象的访问。")]),a._v(" "),s("h3",{attrs:{id:"_2-为什么需要代理模式-代理模式解决了什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么需要代理模式-代理模式解决了什么问题"}},[a._v("#")]),a._v(" 2. 为什么需要代理模式——代理模式解决了什么问题？")]),a._v(" "),s("p",[a._v("代理控制着对于原对象的访问， 并允许在将请求提交给目标对象前后进行一些处理（这些处理可以在代理对象中完成）。")]),a._v(" "),s("p",[a._v("由此，它能解决以下问题：")]),a._v(" "),s("ol",[s("li",[a._v("虚拟代理：通过一个消耗资源较少的对象来代理一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。\n"),s("ul",[s("li",[a._v("无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。也称为延迟初始化。")])])]),a._v(" "),s("li",[a._v("远程代理：适用于目标对象位于远程服务器上的情形。\n"),s("ul",[s("li",[a._v("在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。也称为本地执行远程服务。")])])]),a._v(" "),s("li",[a._v("保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。\n"),s("ul",[s("li",[a._v("代理可仅在客户端凭据满足要求时将请求传递给服务对象。也称为访问控制。")])])]),a._v(" "),s("li",[a._v("缓存代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果。通过管理缓存生命周期，优化系统性能，缩短执行时间。\n"),s("ul",[s("li",[a._v("代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。也称为缓存请求结果。")])])]),a._v(" "),s("li",[a._v("智能引用：可在没有客户端使用某个重量级对象时立即销毁该对象。\n"),s("ul",[s("li",[a._v("理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。")])])])]),a._v(" "),s("h3",{attrs:{id:"_3-静态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-静态代理"}},[a._v("#")]),a._v(" 3. 静态代理")]),a._v(" "),s("p",[a._v("目标对象的代理对象在程序运行前就已经确定。映射到编程领域，就是指代理对象的 "),s("code",[a._v(".class")]),a._v(" 文件在编译时就已经产生了。")]),a._v(" "),s("h3",{attrs:{id:"_4-动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-动态代理"}},[a._v("#")]),a._v(" 4. 动态代理")]),a._v(" "),s("p",[a._v("目标对象的代理对象在程序运行时才能确定。")]),a._v(" "),s("p",[a._v("根据生成代理对象的方式不同，有两种动态代理的实现方式。具体来说，")]),a._v(" "),s("ul",[s("li",[a._v("JDK 动态代理：在程序运行时，通过反射生成代理对象。")]),a._v(" "),s("li",[a._v("CGLib 动态代理：在程序运行时，通过操作字节码生成代理对象。")])]),a._v(" "),s("h4",{attrs:{id:"_4-1-jdk-动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-jdk-动态代理"}},[a._v("#")]),a._v(" 4.1 JDK 动态代理")]),a._v(" "),s("p",[a._v("在 JDK 动态代理机制中，有两个重要的类或接口，一个是 "),s("code",[a._v("InvocationHandler")]),a._v(" 接口、另一个则是 "),s("code",[a._v("Proxy")]),a._v(" 类，这个类和接口是实现动态代理所必须用到的。")]),a._v(" "),s("p",[s("strong",[a._v("InvocationHandler 接口")])]),a._v(" "),s("p",[a._v("每个代理对象都有一个与之关联的 "),s("code",[a._v("InvocationHandler")]),a._v(" 的实现。如果代理对象的方法被调用，那么代理对象便会通知和转发给内部的 "),s("code",[a._v("InvocationHandler")]),a._v(" 实现类，由它处理和返回结果。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InvocationHandler")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("invoke")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" proxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Method")]),a._v(" method"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Throwable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[s("code",[a._v("InvocationHandler")]),a._v(" 内部只有一个 "),s("code",[a._v("invoke()")]),a._v(" 方法，正是这个方法决定了怎么样处理代理对象传递过来的方法调用。")]),a._v(" "),s("p",[s("code",[a._v("invoke()")]),a._v(" 参数的意义：")]),a._v(" "),s("ul",[s("li",[a._v("proxy：代理对象")]),a._v(" "),s("li",[a._v("method：代理对象调用的方法")]),a._v(" "),s("li",[a._v("args：代理对象调用的方法中的参数")])]),a._v(" "),s("p",[s("strong",[a._v("Proxy 类")])]),a._v(" "),s("p",[a._v("JDK 动态代理正是通过 "),s("code",[a._v("Proxy")]),a._v(" 类的静态方法 "),s("code",[a._v("newProxyInstance()")]),a._v(" 创建了代理对象。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Proxy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("newProxyInstance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ClassLoader")]),a._v(" loader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Class")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" interfaces"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InvocationHandler")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[s("code",[a._v("newProxyInstance()")]),a._v(" 参数的意义：")]),a._v(" "),s("ul",[s("li",[a._v("loader：目标对象的类加载器，为了去定义代理类")]),a._v(" "),s("li",[a._v("interfaces：目标对象的接口清单，为了让代理类去实现")]),a._v(" "),s("li",[a._v("h：一个 InvocationHandler 对象，为了分派方法调用")])]),a._v(" "),s("h4",{attrs:{id:"_4-2-cglib-动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-cglib-动态代理"}},[a._v("#")]),a._v(" 4.2 CGLib 动态代理")]),a._v(" "),s("p",[a._v("由于JDK只能针对实现了接口的类做动态代理，而不能对没有实现接口的类做动态代理，所以 CGLib 横空出世！")]),a._v(" "),s("blockquote",[s("p",[a._v("JDK 动态代理强制要求目标类（目标对象）必须最少实现一个接口，但是 CGLib 不要求目标类（目标对象）实现任何接口。")]),a._v(" "),s("p",[a._v("CGLib 动态生成的代理类（代理对象）会继承我们的目标类，并在代理类中对代理方法进行强化处理（前置处理、后置处理等）。")])]),a._v(" "),s("p",[a._v("CGLib（Code Generation Library）是一个强大、高性能的 Code 生成类库，它可以在程序运行期间动态扩展类或接口，它的底层是使用 java 字节码操作框架 ASM 实现。")]),a._v(" "),s("blockquote",[s("p",[a._v("ASM：一个 Java 字节码操作框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 JVM 之前动态改变类行为。Java class 被存储在严格格式定义的 "),s("code",[a._v(".class")]),a._v(" 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新的类。")])]),a._v(" "),s("p",[a._v("在 CGlib 动态代理机制中，需要我们自定一个拦截器实现接口 "),s("code",[a._v("MethodInterceptor")]),a._v("（ "),s("code",[a._v("cglib-nodep")]),a._v(" 库提供）。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MethodInterceptor")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Callback")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("intercept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Method")]),a._v(" method"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MethodProxy")]),a._v(" methodProxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Throwable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[s("code",[a._v("MethodInterceptor")]),a._v(" 内部只有一个 "),s("code",[a._v("intercept()")]),a._v(" 方法，正是这个方法决定了怎么样处理代理对象传递过来的方法调用。")]),a._v(" "),s("p",[s("code",[a._v("intercept()")]),a._v(" 参数的意义：")]),a._v(" "),s("ul",[s("li",[a._v("o：CGLib 生成的代理对象")]),a._v(" "),s("li",[a._v("method：目标对象调用的方法")]),a._v(" "),s("li",[a._v("args：代理对象调用的方法中的参数")]),a._v(" "),s("li",[a._v("methodProxy：代理对象调用的方法")])]),a._v(" "),s("p",[a._v("而代理对象则是由 "),s("code",[a._v("Enhancer")]),a._v(" 类创建的。"),s("code",[a._v("Enhancer")]),a._v(" 是 CGLib 的字节码增强器，可以很方便的对类进行拓展。")]),a._v(" "),s("ol",[s("li",[a._v("创建 enhancer 对象。")]),a._v(" "),s("li",[a._v("利用 enhancer 对象，设置代理类（代理对象）的父类，即目标类。由于目标类会被当作父类，所以目标类不能用 final 修饰，否则报错。同理，目标类中 final 修饰的方法也不会被代理。")]),a._v(" "),s("li",[a._v("利用 enhancer 对象，设置回调函数。动态代理对象根据目标对象的每一个方法都生成了两个方法。第一个代理方法直接调用父类的方法，也就是目标类的方法。第二个方法也就是代理对象真正调用的方法，它是经过封装的，它会去判断代理对象是否实现了 "),s("code",[a._v("MethodInterceptor")]),a._v(" 的 "),s("code",[a._v("intercpt()")]),a._v("方法，如果实现了则会调用 "),s("code",[a._v("intercept()")]),a._v(" 方法。")]),a._v(" "),s("li",[a._v("利用 enhancer 对象，创建代理对象。")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Enhancer")]),a._v(" enhancer "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Enhancer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 设置代理类（代理对象）的父类，即目标对象")]),a._v("\nenhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setSuperclass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("目标对象"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getClass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 设置回调对象，即拦截器")]),a._v("\nenhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setCallback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("实现了 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MethodInterceptor")]),a._v(" 接口的拦截器对象"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 动态生成代理对象")]),a._v("\nenhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h4",{attrs:{id:"_4-3-多级动态代理-jdk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-多级动态代理-jdk"}},[a._v("#")]),a._v(" 4.3 多级动态代理（JDK）")]),a._v(" "),s("p",[a._v("继续开篇的例子，来解释多级代理。")]),a._v(" "),s("p",[a._v("💰做为我们的终极交易介质。而支付类工具（信用卡、支付宝等等）代理了💰，方便我们去支付。但是，现在出现一个问题：市面上出现了很多支付类工具，比如储蓄卡、信用卡、支付宝、微信支付等等，当支付的时候你不得不去思考到底使用哪种工具去支付，进而在手机中找到对应的 app 然后打开支付码进行支付。这真是一个繁琐的过程。幸好，这也有解决的办法。那就是 iphone 自带的 app ：Wallet。Wallet 集成了所有的支付方式，它可以添加储蓄卡、信用卡、支付宝支付码、微信支付码等等，当你需要支付的时候，只需要打开 Wallet 就够了。我们看一下这个流程：")]),a._v(" "),s("Mermaid",{attrs:{id:"mermaid_64a567e6",graph:a.$dataBlock.mermaid_64a567e6}}),s("ul",[s("li",[a._v("💰做为源目标。")]),a._v(" "),s("li",[a._v("支付类工具为一级代理。代理了源目标。目标对象为💰。")]),a._v(" "),s("li",[a._v("钱包类工具为二级代理。代理了一级代理对象。目标对象为一级代理对象。")]),a._v(" "),s("li",[a._v("同样的方式可以实现三级、四级、n级代理。")])])],1)}),[],!1,null,null,null);"function"==typeof e&&e(v);t.default=v.exports}}]);